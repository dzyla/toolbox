<!-- Protein Feature Workbench — fullscreen map + zoom, reordered cards, dark-mode aware -->
<!-- This file works standalone (auto-loads Tailwind + d3 if missing) and inside index.html (uses html.dark). -->

<!-- Optional dependency loader for standalone use -->
<script>
(function ensureDeps(){
  // Tailwind (for standalone)
  if (!window.tailwind || !window.tailwind.configLoadedOnce) {
    window.tailwind = window.tailwind || {};
    window.tailwind.config = { darkMode: 'class' }; // Ensure this matches index.html
    window.tailwind.configLoadedOnce = true;
    var s = document.createElement('script'); s.src = "https://cdn.tailwindcss.com"; document.head.appendChild(s);
  }
  // d3 (for modal zoom)
  if (!window.d3) {
    var d = document.createElement('script'); d.src = "https://d3js.org/d3.v7.min.js"; document.head.appendChild(d);
  }
})();
</script>

<style>
  /* Base fonts */
  body { font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial, "Noto Sans"; }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }

  /* Scrollbars */
  ::-webkit-scrollbar{ width:8px; height:8px;}
  ::-webkit-scrollbar-track{ background:#f8fafc;}
  ::-webkit-scrollbar-thumb{ background:#cbd5e1; border-radius:4px;}
  ::-webkit-scrollbar-thumb:hover{ background:#94a3b8;}

  /* Track (inline and modal) */
  .feature-track-svg { cursor: crosshair; user-select:none; -webkit-user-select:none; }
  .feature-track-svg .feat-rect { transition: opacity 0.15s; cursor: pointer; }
  .feature-track-svg .feat-rect.highlight { stroke: #111827; stroke-width: 2px; }
  .feature-track-svg .seq-bar-bg { fill: #e5e7eb; }
  .feature-track-svg .seq-bar-highlight { fill: rgba(250, 204, 21, 0.7); pointer-events: none; }

  /* Tooltip */
  #svg-tooltip {
    position: absolute; visibility: hidden; background: rgba(17,24,39,0.95); color: #fff;
    padding: 6px 10px; border-radius: 6px; font-size: 12px; pointer-events: none;
    white-space: nowrap; transition: opacity 0.1s; z-index: 100; line-height: 1.5;
  }

  /* Feature list */
  .feature-list-item:hover { background-color: #eef2ff; }
  .feature-list-item.active { background-color: #e0e7ff; outline: 2px solid #93c5fd; }

  /* Charts */
  .mini-chart-container { position: relative; }
  .mini-chart { width: 100%; height: 150px; }
  .mini-track { width: 100%; height: 40px; }
  .chart-title { font-size: 0.9rem; color: #374151; margin-bottom: 0.25rem; }
  .hover-line { stroke: #9ca3af; stroke-width: 1px; stroke-dasharray: 4 2; pointer-events: none; }

  .card-pad { padding: 1rem; }
  .note { font-size: 11px; color: #6b7280; }
  .note b { color: #374151; }

  /* Fullscreen modal */
  .map-modal-backdrop {
    position: fixed; inset: 0; background: rgba(0,0,0,0.6);
    display: none; align-items: center; justify-content: center; z-index: 50;
  }
  .map-modal-backdrop.open { display: flex; }
  .map-modal-content {
    width: min(1400px, 96vw);
    max-height: 90vh;
    background: #fff; border-radius: 0.75rem; padding: 0.75rem;
    box-shadow: 0 20px 60px rgba(0,0,0,0.35);
    display: flex; flex-direction: column; gap: 0.5rem;
  }
  .map-modal-header { display: flex; align-items:center; justify-content: space-between; gap: 0.5rem; }
  .map-modal-body { overflow: auto; border: 1px solid #e5e7eb; border-radius: 0.5rem; background: #fff; }
  .map-modal-body svg { display:block; width: 100%; height: auto; }
  .map-modal-kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas; border:1px solid #cbd5e1; border-bottom-width:2px; padding: 0 0.4rem; border-radius:0.375rem; font-size: 0.75rem; }

  /* Lab tools table */
  .lab-table { width: 100%; font-size: 0.75rem; text-align: left; border-collapse: collapse; }
  .lab-table th, .lab-table td { padding: 4px 8px; border-bottom: 1px solid #e5e7eb; }
  .lab-table th { background: #f9fafb; font-weight: 600; color: #374151; }
  .lab-table tr:hover { background: #f9fafb; }
  .lab-table tr.highlight-match { background: #dcfce7; }

  /* Dark mode fallbacks if Tailwind dark utilities are not present */
  html.dark .feature-track-svg .seq-bar-bg { fill: #1f2937; }
  html.dark .chart-title, html.dark .note, html.dark .lab-table th { color: #94a3b8; }
  html.dark .feature-list-item:hover { background-color: rgba(99,102,241,0.12); }
  html.dark .feature-list-item.active { background-color: rgba(99,102,241,0.18); outline-color: #a5b4fc; }
  html.dark .map-modal-content { background:#0f172a; color:#e5e7eb; }
  html.dark .map-modal-body { background:#0f172a; border-color:#334155; }
  html.dark .map-modal-kbd { border-color:#334155; }
  html.dark ::-webkit-scrollbar-track{ background: #0b1220; }
  html.dark ::-webkit-scrollbar-thumb{ background:#475569; }
  html.dark ::-webkit-scrollbar-thumb:hover{ background:#64748b; }
  html.dark .lab-table th { background: #1e293b; border-color: #334155; }
  html.dark .lab-table td { border-color: #334155; }
  html.dark .lab-table tr:hover { background: #1e293b; }
  html.dark .lab-table tr.highlight-match { background: #064e3b; }
</style>
<style id="map-modal-size-override">
  /* Make the zoom modal almost fullscreen for more vertical space */
  .map-modal-content{
    width: 98vw !important;
    max-width: 98vw !important;
    height: 96vh !important;
    max-height: 96vh !important;
  }
  .map-modal-body{
    /* Let the body grow to fill the modal height */
    flex: 1 1 auto !important;
    height: auto !important;
    min-height: calc(96vh - 64px) !important; /* header height allowance */
  }
</style>


<div id="svg-tooltip"></div>

<div class="mx-auto max-w-6xl p-4 md:p-8">
  <header class="mb-4 md:mb-6">
    <div class="flex items-center justify-between gap-3">
      <div>
        <h1 class="text-2xl md:text-3xl font-extrabold tracking-tight text-slate-900 dark:text-white">Protein Feature Workbench</h1>
        <p class="mt-1 text-gray-600 dark:text-gray-400 text-sm md:text-base">ProtParam-like core with graphical maps, per-residue plots, and lab helpers.</p>
      </div>
      <div class="hidden md:flex items-center gap-2">
        <button id="export_all_csv" class="text-sm bg-slate-900 text-white px-3 py-2 rounded-lg hover:bg-black">Export summary CSV</button>
        <button id="toggle_all_plots" class="text-sm bg-white border border-slate-300 px-3 py-2 rounded-lg hover:bg-slate-50 dark:bg-slate-800 dark:border-slate-600 dark:hover:bg-slate-700 dark:text-slate-100">Toggle plots</button>
      </div>
    </div>
  </header>

  <!-- Input card -->
  <section class="bg-white text-slate-900 dark:bg-slate-800 dark:text-slate-100 border border-gray-200 dark:border-gray-700 card-pad rounded-2xl shadow-sm transition-colors">
    <div class="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-4">
      <div>
        <label for="fasta_input" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Paste FASTA sequences</label>
        <textarea id="fasta_input" rows="8"
          class="w-full p-3 border bg-white text-slate-900 border-gray-300 focus:ring-indigo-500 dark:bg-slate-900 dark:text-slate-100 dark:border-gray-600 rounded-xl focus:ring-2 focus:border-indigo-500 transition mono"
          placeholder="Paste FASTA or a raw sequence. Comments starting with ';' are ignored."></textarea>
        <div class="flex items-center flex-wrap gap-3 mt-2">
          <button id="load_example" class="text-sm text-indigo-700 dark:text-indigo-400 hover:underline">Load example</button>
          <span class="text-xs text-gray-500 dark:text-gray-400">Ambiguous B, Z, J, X and U (Sec), O (Pyl) supported.</span>
        </div>
      </div>
      <div>
        <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Or upload a FASTA file</label>
        <input type="file" id="file_input" accept=".fasta,.fa,.faa,.fna"
          class="w-full text-sm text-gray-700 dark:text-gray-300 file:mr-3 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 dark:file:bg-indigo-900/30 file:text-indigo-700 dark:file:text-indigo-300 hover:file:bg-indigo-100 dark:hover:file:bg-indigo-900/50"/>

        <div class="mt-4">
          <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">User Defined Domains (CSV)</label>
          <div class="flex items-center gap-2">
             <input type="file" id="user_domains_csv" accept=".csv"
              class="w-full text-sm text-gray-700 dark:text-gray-300 file:mr-3 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 dark:file:bg-indigo-900/30 file:text-indigo-700 dark:file:text-indigo-300 hover:file:bg-indigo-100 dark:hover:file:bg-indigo-900/50"/>
             <button id="show_csv_example" class="text-xs text-indigo-600 dark:text-indigo-400 hover:underline shrink-0">Show example</button>
          </div>
          <p class="text-xs text-gray-500 dark:text-gray-400 mt-1">Upload a CSV with <code>Name,Sequence</code> to mark custom regions.</p>
        </div>

        <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 mt-4">
          <div>
            <h3 class="text-sm font-semibold dark:text-slate-200">Analysis Settings</h3>
            <div class="space-y-2 mt-1">
              <div>
                <label class="block text-xs mb-1 text-gray-700 dark:text-slate-300">Reference pH (Charge)</label>
                <div class="flex items-center gap-2">
                  <input id="ref_pH" type="number" min="0" max="14" step="0.1" value="7.4"
                    class="w-16 p-1.5 border border-gray-300 dark:border-gray-600 bg-white text-slate-900 dark:bg-slate-900 dark:text-slate-100 rounded-lg focus:ring-2 focus:ring-indigo-500 transition text-sm"/>
                  <input id="ref_pH_slider" type="range" min="0" max="14" step="0.1" value="7.4" class="w-full">
                </div>
              </div>
              <div>
                <label class="block text-xs mb-1 text-gray-700 dark:text-slate-300">N-end rule Organism</label>
                <select id="half_life_org" class="w-full p-1.5 border border-gray-300 dark:border-gray-600 bg-white text-slate-900 dark:bg-slate-900 dark:text-slate-100 rounded-lg focus:ring-2 focus:ring-indigo-500 transition text-sm">
                  <option value="mammal" selected>Mammalian</option>
                  <option value="yeast">Yeast</option>
                  <option value="ecoli">E. coli</option>
                </select>
              </div>
            </div>
          </div>
          <div>
            <h3 class="text-sm font-semibold dark:text-slate-200">Domain Detection</h3>
            <div class="mt-1">
              <label class="block text-xs mb-1 text-gray-700 dark:text-slate-300">Min. Identity %</label>
              <div class="flex items-center gap-2">
                 <input id="domain_thr" type="number" min="50" max="100" step="1" value="95"
                    class="w-16 p-1.5 border border-gray-300 dark:border-gray-600 bg-white text-slate-900 dark:bg-slate-900 dark:text-slate-100 rounded-lg focus:ring-2 focus:ring-indigo-500 transition text-sm"/>
                 <input id="domain_thr_slider" type="range" min="50" max="100" step="1" value="95" class="w-full">
              </div>
              <p class="text-[10px] text-gray-500 dark:text-gray-400 mt-1">For Large Domains (e.g. GFP, GST).</p>
            </div>
          </div>
          <div>
            <h3 class="text-sm font-semibold dark:text-slate-200">Transmembrane</h3>
            <div class="grid grid-cols-2 gap-2 mt-1">
              <div>
                <label class="block text-xs mb-1 text-gray-700 dark:text-slate-300">Window (11–35)</label>
                <input id="tm_window" type="number" min="11" max="35" step="1" value="19"
                  class="w-full p-1.5 border border-gray-300 dark:border-gray-600 bg-white text-slate-900 dark:bg-slate-900 dark:text-slate-100 rounded-lg focus:ring-2 focus:ring-indigo-500 transition text-sm"/>
              </div>
              <div>
                <label class="block text-xs mb-1 text-gray-700 dark:text-slate-300">KD threshold</label>
                <input id="tm_thr" type="number" step="0.1" value="1.6"
                  class="w-full p-1.5 border border-gray-300 dark:border-gray-600 bg-white text-slate-900 dark:bg-slate-900 dark:text-slate-100 rounded-lg focus:ring-2 focus:ring-indigo-500 transition text-sm"/>
              </div>
            </div>
          </div>
        </div>

        <details class="mt-4" open>
          <summary class="cursor-pointer text-sm font-semibold text-slate-800 dark:text-slate-200">Plots & Analysis Settings</summary>
          <div class="grid grid-cols-1 lg:grid-cols-3 gap-4 mt-3">
            <div>
              <h4 class="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase">Plots Enabled</h4>
              <div class="grid grid-cols-2 lg:grid-cols-1 gap-2 mt-1">
                <label class="flex items-center gap-2 text-sm text-gray-700 dark:text-slate-300"><input type="checkbox" id="opt_hydro" class="h-4 w-4 rounded border-gray-300 dark:border-gray-600 dark:bg-slate-700" checked>Hydrophobicity</label>
                <label class="flex items-center gap-2 text-sm text-gray-700 dark:text-slate-300"><input type="checkbox" id="opt_charge" class="h-4 w-4 rounded border-gray-300 dark:border-gray-600 dark:bg-slate-700" checked>Charge</label>
                <label class="flex items-center gap-2 text-sm text-gray-700 dark:text-slate-300"><input type="checkbox" id="opt_disorder" class="h-4 w-4 rounded border-gray-300 dark:border-gray-600 dark:bg-slate-700">Disorder (FoldIndex)</label>
                <label class="flex items-center gap-2 text-sm text-gray-700 dark:text-slate-300"><input type="checkbox" id="opt_moment" class="h-4 w-4 rounded border-gray-300 dark:border-gray-600 dark:bg-slate-700">Hydrophobic Moment</label>
                <label class="flex items-center gap-2 text-sm text-gray-700 dark:text-slate-300"><input type="checkbox" id="opt_secstruct" class="h-4 w-4 rounded border-gray-300 dark:border-gray-600 dark:bg-slate-700">Sec. Struct (Chou-Fasman)</label>
                <label class="flex items-center gap-2 text-sm text-gray-700 dark:text-slate-300"><input type="checkbox" id="opt_cys" class="h-4 w-4 rounded border-gray-300 dark:border-gray-600 dark:bg-slate-700" checked>Cysteine positions</label>
              </div>
            </div>
            <div>
              <h4 class="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase">Map Features</h4>
              <div class="grid grid-cols-2 lg:grid-cols-1 gap-2 mt-1">
                <label class="flex items-center gap-2 text-sm text-gray-700 dark:text-slate-300"><input type="checkbox" id="feat_topology" class="h-4 w-4 rounded border-gray-300 dark:border-gray-600 dark:bg-slate-700" checked>Topology (TM, Signal)</label>
                <label class="flex items-center gap-2 text-sm text-gray-700 dark:text-slate-300"><input type="checkbox" id="feat_ptm" class="h-4 w-4 rounded border-gray-300 dark:border-gray-600 dark:bg-slate-700">PTMs (Motifs)</label>
                <label class="flex items-center gap-2 text-sm text-gray-700 dark:text-slate-300"><input type="checkbox" id="feat_domain" class="h-4 w-4 rounded border-gray-300 dark:border-gray-600 dark:bg-slate-700" checked>Domains & Degrons</label>
                <label class="flex items-center gap-2 text-sm text-gray-700 dark:text-slate-300"><input type="checkbox" id="feat_local" class="h-4 w-4 rounded border-gray-300 dark:border-gray-600 dark:bg-slate-700" checked>Localization</label>
                <label class="flex items-center gap-2 text-sm text-gray-700 dark:text-slate-300"><input type="checkbox" id="feat_tags" class="h-4 w-4 rounded border-gray-300 dark:border-gray-600 dark:bg-slate-700" checked>Tags & Sites</label>
                <label class="flex items-center gap-2 text-sm text-gray-700 dark:text-slate-300"><input type="checkbox" id="feat_user" class="h-4 w-4 rounded border-gray-300 dark:border-gray-600 dark:bg-slate-700" checked>User Domains</label>
              </div>
            </div>
            <div>
              <h4 class="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase">Smoothing Windows</h4>
              <div class="grid grid-cols-2 lg:grid-cols-1 gap-3 mt-1">
                <div>
                  <label class="block text-xs mb-1 text-gray-700 dark:text-slate-300" for="hydro_window">Hydrophobicity</label>
                  <select id="hydro_window" class="w-full p-1.5 border border-gray-300 dark:border-gray-600 bg-white text-slate-900 dark:bg-slate-900 dark:text-slate-100 rounded-lg text-sm">
                    <option value="1">1</option><option value="3">3</option><option value="5" selected>5</option><option value="9">9</option><option value="13">13</option>
                  </select>
                </div>
                <div>
                  <label class="block text-xs mb-1 text-gray-700 dark:text-slate-300" for="charge_window">Charge</label>
                  <select id="charge_window" class="w-full p-1.5 border border-gray-300 dark:border-gray-600 bg-white text-slate-900 dark:bg-slate-900 dark:text-slate-100 rounded-lg text-sm">
                    <option value="1">1</option><option value="5">5</option><option value="9" selected>9</option><option value="15">15</option>
                  </select>
                </div>
              </div>
            </div>
          </div>
        </details>
      </div>
    </div>

    <div class="mt-5 flex items-center justify-center gap-3 flex-wrap">
      <button id="analyze_button" class="bg-indigo-600 text-white font-semibold py-2 px-6 rounded-full hover:bg-indigo-700 transition-colors shadow-sm">Analyze</button>
      <button id="clear_button" class="bg-white dark:bg-slate-700 border border-gray-300 dark:border-gray-600 text-gray-800 dark:text-white font-semibold py-2 px-6 rounded-full hover:bg-gray-50 dark:hover:bg-slate-600 transition-colors shadow-sm">Clear</button>
      <button id="expand_all" class="text-sm text-indigo-700 dark:text-indigo-400 hover:underline">Expand all cards</button>
      <button id="collapse_all" class="text-sm text-indigo-700 dark:text-indigo-400 hover:underline">Collapse all cards</button>
    </div>

    <p class="mt-3 text-xs text-gray-500 dark:text-gray-400">
      Masses use monoisotopic residues (+H<sub>2</sub>O). Charge/pI use Henderson–Hasselbalch.
      Experimental predictions (Disorder, Half-life) are estimates.
    </p>
  </section>

  <section id="results_section" class="mt-6 space-y-4"></section>
</div>

<!-- Fullscreen map modal (shared) -->
<div id="map-modal" class="map-modal-backdrop" aria-hidden="true">
  <div class="map-modal-content">
    <div class="map-modal-header">
      <div class="text-sm opacity-80">Scroll to zoom • drag to pan • press <span class="map-modal-kbd">Esc</span> to close</div>
      <div class="flex items-center gap-2">
        <button id="map-reset" class="text-xs bg-white border border-slate-300 px-2.5 py-1.5 rounded-lg hover:bg-slate-50 dark:bg-slate-800 dark:border-slate-600 dark:text-slate-100 dark:hover:bg-slate-700">Reset view</button>
        <button id="map-close" class="text-xs bg-slate-900 text-white px-2.5 py-1.5 rounded-lg hover:bg-black">Close</button>
      </div>
    </div>
    <div id="map-modal-body" class="map-modal-body"></div>
  </div>
</div>

<script>
window.initProteinWorkbench = function(){
  // Load Definitions from global object
  const DEFS = window.PROTEIN_DEFS || {};
  const UTILS = window.PROTEIN_UTILS || {};
  if(!DEFS.AA || !UTILS.getProteinParams){ alert("Error: definitions.js not loaded."); return; }
  
  const AA = DEFS.AA;
  const DIWV = DEFS.DIWV;
  const TAGS = DEFS.TAGS;
  const MOTIFS = DEFS.MOTIFS;
  const LARGE_TAGS = DEFS.LARGE_TAGS;

  const pKaSets = {
      bjell: {
          term: { N: AA.pKa_term.N, C: AA.pKa_term.C },
          side: { ...AA.pKa_side }
      },
      emboss: {
          term: { N: 8.6, C: 3.6 },
          side: { K: 10.8, R: 12.5, H: 6.5, D: 3.9, E: 4.1, C: 8.5, Y: 10.1 }
      }
  };

  /* ===== DOM elements ===== */
  const els = {
    fasta: document.getElementById('fasta_input'),
    file: document.getElementById('file_input'),
    userDomainsCsv: document.getElementById('user_domains_csv'),
    showCsvExample: document.getElementById('show_csv_example'),
    analyze: document.getElementById('analyze_button'),
    clear: document.getElementById('clear_button'),
    results: document.getElementById('results_section'),
    pH: document.getElementById('ref_pH'),
    pHslider: document.getElementById('ref_pH_slider'),
    domainThr: document.getElementById('domain_thr'),
    domainThrSlider: document.getElementById('domain_thr_slider'),
    tmWindow: document.getElementById('tm_window'),
    tmThr: document.getElementById('tm_thr'),
    loadExample: document.getElementById('load_example'),
    tooltip: document.getElementById('svg-tooltip'),
    
    // Plots & Options
    optHydro: document.getElementById('opt_hydro'),
    optCharge: document.getElementById('opt_charge'),
    optDisorder: document.getElementById('opt_disorder'),
    optMoment: document.getElementById('opt_moment'),
    optSecStruct: document.getElementById('opt_secstruct'),
    optCys: document.getElementById('opt_cys'),

    // Feature Filters
    featTopology: document.getElementById('feat_topology'),
    featPtm: document.getElementById('feat_ptm'),
    featDomain: document.getElementById('feat_domain'),
    featLocal: document.getElementById('feat_local'),
    featTags: document.getElementById('feat_tags'),
    featUser: document.getElementById('feat_user'),

    halfLifeOrg: document.getElementById('half_life_org'),
    
    hydroWindow: document.getElementById('hydro_window'),
    chargeWindow: document.getElementById('charge_window'),
    
    exportAllCsv: document.getElementById('export_all_csv'),
    toggleAllPlots: document.getElementById('toggle_all_plots'),
    expandAll: document.getElementById('expand_all'),
    collapseAll: document.getElementById('collapse_all'),
    modal: document.getElementById('map-modal'),
    modalBody: document.getElementById('map-modal-body'),
    modalClose: document.getElementById('map-close'),
    modalReset: document.getElementById('map-reset'),
  };

  let resultCounter=0, currentResults=[];
  let plotsVisible=true;
  let modalState = { svg: null, zoom: null };
  let userDomains = [];

  /* ===== Core calculations ===== */
  // USE SHARED UTILITIES
  const countAA = UTILS.countAA;
  const molecularWeight = UTILS.molecularWeight;
  const extinctionCoefficients = UTILS.extinctionCoefficients;

  function gravy(seq){ if(!seq.length) return 0; let s=0; for(const a of seq) s += (AA.kd[a] ?? 0); return s/seq.length; }

  function netCharge(counts, pH, scheme='bjell'){
    const pK = pKaSets[scheme] || pKaSets.bjell;
    let p = 1/(1+10**(pH - pK.term.N));
    p += (counts.K||0)/(1+10**(pH - pK.side.K));
    p += (counts.R||0)/(1+10**(pH - pK.side.R));
    p += (counts.H||0)/(1+10**(pH - pK.side.H));
    let n = 1/(1+10**(pK.term.C - pH));
    n += (counts.D||0)/(1+10**(pK.side.D - pH));
    n += (counts.E||0)/(1+10**(pK.side.E - pH));
    n += (counts.C||0)/(1+10**(pK.side.C - pH));
    n += (counts.Y||0)/(1+10**(pK.side.Y - pH));
    return p - n;
  }
  function isoelectricPoint(counts, scheme='bjell'){
    let lo=0.0, hi=14.0;
    for(let i=0;i<60;i++){ const mid=(lo+hi)/2; if(netCharge(counts, mid, scheme)>0) lo=mid; else hi=mid; }
    return (lo+hi)/2;
  }
  function instabilityIndex(seq){
    if(seq.length < 2) return 0;
    let score = 0;
    for(let i=0;i<seq.length-1;i++){ const a=seq[i], b=seq[i+1]; if (DIWV[a] && typeof DIWV[a][b] !== 'undefined') score += DIWV[a][b]; }
    return (10 / seq.length) * score;
  }

  /* --- New Feature Calculations --- */
  function aliphaticIndex(counts, len){
    if(!len) return 0;
    const XA = (counts.A||0)/len*100;
    const XV = (counts.V||0)/len*100;
    const XI = (counts.I||0)/len*100;
    const XL = (counts.L||0)/len*100;
    return XA + 2.9*XV + 3.9*(XI+XL);
  }

  function atomicFormula(counts){
    const atoms = {C:0, H:0, N:0, O:0, S:0, Se:0};
    atoms.H += 2; atoms.O += 1;
    for(const aa in counts){
      const n = counts[aa] || 0;
      const def = AA.atoms[aa];
      if(def && n > 0){
        for(const el in def) atoms[el] = (atoms[el]||0) + def[el]*n;
      }
    }
    const order = ['C', 'H', 'N', 'O', 'S', 'Se'];
    return order.map(el => atoms[el] > 0 ? `${el}${atoms[el]}` : '').join('');
  }

  function estimatedHalfLife(seq, organism){
    if(!seq.length) return "Unknown";
    const n = seq[0];
    const table = DEFS.HALF_LIFE[organism];
    if(table && table[n]) return table[n];
    return "Unknown";
  }

  /* --- Per Residue Arrays --- */
  function fractionalCharge(res, pH){
    const s = AA.pKa_side;
    switch(res){
      case 'K': return 1/(1+10**(pH - s.K));
      case 'R': return 1/(1+10**(pH - s.R));
      case 'H': return 1/(1+10**(pH - s.H));
      case 'D': return -1/(1+10**(s.D - pH));
      case 'E': return -1/(1+10**(s.E - pH));
      case 'C': return -1/(1+10**(s.C - pH));
      case 'Y': return -1/(1+10**(s.Y - pH));
      default: return 0;
    }
  }
  function perResidueChargeArray(seq, pH){
    const arr = new Array(seq.length).fill(0);
    for(let i=0;i<seq.length;i++) arr[i] = fractionalCharge(seq[i], pH);
    if(seq.length>0){
      arr[0] += 1/(1+10**(pH - AA.pKa_term.N));
      arr[seq.length-1] += -1/(1+10**(AA.pKa_term.C - pH));
    }
    return arr;
  }

  /* ===== Feature scanning ===== */
  function mergeSegments(arr){
    if(!arr.length) return [];
    arr.sort((a,b)=> a.start - b.start || a.end - b.end);
    const out=[{...arr[0]}];
    for(let i=1;i<arr.length;i++){
      const last = out[out.length-1], cur = arr[i];
      const sameClass = (cur.category===last.category) && (cur.name===last.name);
      if(sameClass && cur.start <= last.end + 1) last.end = Math.max(last.end, cur.end);
      else out.push({...cur});
    }
    return out;
  }
  function kdAverage(seq, i, w){ let s=0; for(let k=0;k<w;k++) s += (AA.kd[seq[i+k]] ?? 0); return s / w; }
  function transmembranes(seq, w=19, thr=1.6){
    const feats=[];
    for(let i=0;i<=seq.length-w;i++){
      if(kdAverage(seq,i,w) >= thr){
        let j=i+w; while(j<seq.length && kdAverage(seq, j - w + 1, w) >= (thr - 0.2)) j++;
        feats.push({ start:i, end:j-1, name:"Transmembrane", category:"Topology", color:"#34d399" });
        i = j-1;
      }
    }
    return mergeSegments(feats);
  }
  function signalPeptideCandidates(seq){
    const feats=[]; const N= Math.min(30, seq.length);
    let i=0;
    while(i<=N-7){
      if(kdAverage(seq,i,7) >= 1.6){
        let j=i+7; while(j<N && kdAverage(seq, j-6, 7) >= 1.2) j++;
        feats.push({ start:i, end:j-1, name:"Signal peptide (candidate)", category:"Topology", color:"#fb7185", note:"Heuristic: hydrophobic stretch near N-terminus." });
        i=j;
      } else i++;
    }
    return feats;
  }
  function scanLargeDomains(seq, threshold){
    const feats=[];
    for(const name in LARGE_TAGS){
        const def = LARGE_TAGS[name];
        const query = def.seq;
        const L = query.length;
        if(seq.length < L) continue;
        for(let i=0; i <= seq.length - L; i++){
            let matches = 0;
            for(let j=0; j<L; j++){
                if(seq[i+j] === query[j]) matches++;
            }
            const identity = (matches / L) * 100;
            if(identity >= threshold){
                const matchedSeq = seq.slice(i, i+L);
                feats.push({
                    start: i,
                    end: i + L - 1,
                    name: name,
                    category: def.category || "Large Domain",
                    color: def.color || "#a855f7",
                    note: `${def.note || ""} (Identity: ${identity.toFixed(1)}%)`,
                    match: matchedSeq
                });
                i += L - 1;
            }
        }
    }
    return feats;
  }

  function scanFeatures(seq, threshold=100){
    const feats=[];
    for(const name in TAGS){
      const def = TAGS[name];
      for(const pattern of def.seqs){
        let idx = seq.indexOf(pattern);
        while(idx !== -1){
          feats.push({ start: idx, end: idx + pattern.length - 1, name, match: pattern, note: "Tag/site match.", ...def });
          idx = seq.indexOf(pattern, idx+1);
        }
      }
    }
    for(const m of MOTIFS){
      const re = new RegExp(m.regex.source, m.regex.flags);
      let match;
      while((match = re.exec(seq)) !== null){
        const start = match.index, len = match[0].length;
        feats.push({ start, end: start + len - 1, name: m.name, color: m.color, category: m.category, match: match[0], note: m.note || "" });
        if (len === 0) re.lastIndex++;
      }
    }
    const largeFeats = scanLargeDomains(seq, threshold);
    feats.push(...largeFeats);
    if(userDomains && userDomains.length > 0) {
        userDomains.forEach(ud => {
            if(!ud.seq) return;
            let idx = seq.indexOf(ud.seq);
            while(idx !== -1) {
                feats.push({ start: idx, end: idx + ud.seq.length - 1, name: ud.name, category: "User Domains", color: "#6366f1", match: ud.seq, note: "User defined" });
                idx = seq.indexOf(ud.seq, idx + 1);
            }
        });
    }
    return feats;
  }

  function getResidueStats(seq) {
    const counts = countAA(seq);
    const std = Array.from("ACDEFGHIKLMNPQRSTVWY");
    const total = seq.length;
    const pct = {};
    std.forEach(aa => { const n = counts[aa] || 0; pct[aa] = ((n/Math.max(1,total))*100).toFixed(2); });
    return { counts, pct, total, order: std };
  }

  // Use Shared Parsing
  const parseFastaFlexible = UTILS.parseFastaFlexible;
  const sanitizeSequenceWithLog = UTILS.sanitizeSequenceWithLog;

  /* ===== UI: inputs ===== */
  els.file.addEventListener('change', e=>{
    const f=e.target.files[0];
    if(!f) return;
    if(f.size>5*1024*1024){ alert("File too large. Limit is 5 MB."); e.target.value=""; return; }
    const r=new FileReader();
    r.onload=ev=>{ els.fasta.value=ev.target.result; };
    r.readAsText(f);
  });
  els.userDomainsCsv.addEventListener('change', e => {
     const f = e.target.files[0]; if(!f) return; const r = new FileReader();
     r.onload = ev => {
         const txt = ev.target.result; const lines = txt.split(/\r?\n/);
         userDomains = []; let count = 0;
         lines.forEach(line => {
             const parts = line.split(',');
             if(parts.length >= 2) {
                 const name = parts[0].trim();
                 const seq = parts[1].trim().toUpperCase().replace(/[^A-Z]/g, '');
                 if(name && seq) { userDomains.push({name, seq}); count++; }
             }
         });
         if(count > 0) alert(`Loaded ${count} user domains.`);
     };
     r.readAsText(f);
  });
  els.showCsvExample.addEventListener('click', () => { alert("CSV Format Example:\n\nMyDomain,ACDEFGH\nActiveSite,YGGFL\n\nNo header row required."); });
  els.loadExample.addEventListener('click', ()=>{ els.fasta.value = `>sp|P0DP23|VIME_HUMAN Vimentin\nMSTRSVSSSSYRRMFGGPGTASRPSSSRSYVTTSTRTYSLGSALRPSTSRSLYASSPGGVYATRSSAVRLR\nSSVPGVRLLQDSVDFSLADAINTEFKNTRTNEKVELQELNDRFANYIDKVRFLEQQNKILLAELEQLKGQ\nGKSRLGDLYEEEMRELRRQVDQLTNDKARVEVERDNLAEDIMRLREKLQEEMLQRQEEAENNLAAFRADV\nDAATLARIDLERRIENLSIEELLCKSDASGYARVFGADLERAKEKLNVEAMHEFVQQLARAEEDNYRGVL\nSLTPIEFRAGEPYSDRHGYFAVYEELARTKKLDSVGSEALSVRQGHDVFLARKLLEIPALEFSSVQNQSL\nQTSVDVFYVPKFEAAVRTFTREAGSEVSELTDSFRQKYETAVREMESIRRLLMELQSLARQYEEHVRSMN`; });
  els.clear.addEventListener('click', ()=>{ els.fasta.value=""; els.results.innerHTML=""; resultCounter=0; currentResults=[]; });
  function syncPHInputs(from){ if(from==='slider'){ els.pH.value = Number(els.pHslider.value).toFixed(1); } if(from==='box'){ els.pHslider.value = els.pH.value; } refreshAllPlots(); refreshCharges(); }
  els.pHslider.addEventListener('input', ()=>syncPHInputs('slider')); els.pH.addEventListener('change', ()=>syncPHInputs('box'));
  function syncDomainThr(from){ if(from==='slider'){ els.domainThr.value = els.domainThrSlider.value; } if(from==='box'){ els.domainThrSlider.value = els.domainThr.value; } refreshAllCards(); }
  els.domainThrSlider.addEventListener('input', ()=>syncDomainThr('slider')); els.domainThr.addEventListener('change', ()=>syncDomainThr('box'));
  [
      els.optHydro, els.optCharge, els.optDisorder, els.optMoment, els.optSecStruct, els.optCys,
      els.hydroWindow, els.chargeWindow, els.tmWindow, els.tmThr, els.halfLifeOrg,
      els.featTopology, els.featPtm, els.featDomain, els.featLocal, els.featTags, els.featUser
  ].forEach(c=>{ c.addEventListener('change', ()=> { refreshAllCards(); }); });

  els.analyze.addEventListener('click', ()=>{
    const t=els.fasta.value.trim(); if(!t){ alert("Please paste or upload sequences."); return; }
    els.results.innerHTML=""; currentResults=[];
    try{
      const records = parseFastaFlexible(t);
      if(!records.length) throw new Error("No sequence letters found.");
      for(const item of records){
        try{
          const { seq, issues, notes } = sanitizeSequenceWithLog(item.seq);
          if(seq.length === 0) throw new Error("Sequence contains no valid residues after cleaning.");
          const obj=analyzeSingle({ header: item.header, seq });
          obj.parseNotes = notes; obj.parseIssues = issues;
          currentResults.push(obj); buildResultCard(obj);
        }catch(e){ showErrorCard(`Error analyzing: ${item.header}`, e.message); }
      }
      refreshAllCards();
    }catch(e){ showErrorCard("Parse error", e.message); }
  });

  function analyzeSingle(item){
    const s = item.seq; const L = s.length; const c = countAA(s);
    const tmW = parseInt(els.tmWindow.value,10); const tmT = Number(els.tmThr.value);
    const domThr = Number(els.domainThr.value);
    const mw = molecularWeight(c);
    const tmSegs = transmembranes(s, tmW, tmT);
    const spSegs = signalPeptideCandidates(s);
    const motifSegs = scanFeatures(s, domThr);
    const allFeats = mergeSegments([ ...tmSegs, ...spSegs, ...motifSegs ]);
    const aliIdx = aliphaticIndex(c, L);
    const atomForm = atomicFormula(c);
    const hLife = estimatedHalfLife(s, els.halfLifeOrg.value);

    return {
      id: ++resultCounter, header: item.header, seq: s, length: L,
      molecularWeight: mw,
      pI: isoelectricPoint(c), // Default scheme
      chargeAtPH: netCharge(c, Number(els.pH.value)),
      gravy: gravy(s), aliphaticIndex: aliIdx, atomicFormula: atomForm, halfLife: hLife,
      extinction: extinctionCoefficients(c, mw),
      instability: instabilityIndex(s), features: allFeats, counts: c
    };
  }

  function escapeHTML(s){ return String(s).replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
  function showErrorCard(title, msg){ els.results.insertAdjacentHTML('beforeend', `<div class="bg-red-50 border border-red-200 text-red-800 px-4 py-3 rounded-xl"><h3 class="font-semibold">${escapeHTML(title)}</h3><div class="text-sm mt-1">${escapeHTML(msg)}</div></div>`); }

  function buildFeatureListHTML(byLane){
    const keys = Object.keys(byLane); if(keys.length === 0) return '<p class="text-sm text-gray-500">No features found.</p>';
    return keys.sort().map(category => {
      const items = byLane[category].map(f => {
        const extra = f.match ? ` • <span class="mono text-xs bg-slate-100 dark:bg-slate-700 px-1 rounded">${f.match}</span>` : '';
        const note = f.note ? ` <span class="text-xs text-gray-600 dark:text-gray-400">(${f.note})</span>` : '';
        return `<li class="feature-list-item p-2 rounded-md cursor-pointer dark:text-slate-200" data-start="${f.start}" data-end="${f.end}" data-name="${f.name}" data-category="${category}" data-match="${f.match||''}" data-note="${f.note||''}">
          <span class="font-semibold text-sm">${f.name}</span>${note}
          <span class="mono text-xs text-gray-600 dark:text-gray-400 ml-2">[${f.start+1}..${f.end+1}]</span>${extra}
        </li>`;
      }).join('');
      return `<details open class="mb-2"><summary class="font-semibold cursor-pointer text-gray-800 dark:text-slate-100">${category} (${byLane[category].length})</summary><ul class="mt-1 pl-2 space-y-1">${items}</ul></details>`;
    }).join('');
  }

  function buildResultCard(obj){
    const stabilityText = obj.instability < 40 ? `<span class="text-green-700 dark:text-green-400 font-semibold">Stable</span>` : `<span class="text-red-700 dark:text-red-400 font-semibold">Unstable</span>`;
    const byLane = obj.features.reduce((acc, f) => { (acc[f.category] = acc[f.category] || []).push(f); return acc; }, {});
    const stats = getResidueStats(obj.seq);
    const statsRows = stats.order.map(aa => { const n = stats.counts[aa] || 0; const p = stats.pct[aa]; return `<tr><td class="px-1 mono">${aa}</td><td class="px-1 text-right">${n}</td><td class="px-1 text-right">${p}%</td></tr>`; }).join('');
    const parsingNote = (obj.parseNotes || obj.parseIssues) ? `<div class="note mt-1">Parsing notes: ${[obj.parseNotes, obj.parseIssues].filter(Boolean).join('; ')}</div>` : '';

    const card = `
      <div id="result-card-${obj.id}" class="bg-white dark:bg-slate-800 border border-gray-100 dark:border-gray-700 rounded-2xl shadow-sm transition-colors">
        <div class="p-4 md:p-5">
          <div class="flex flex-col md:flex-row md:items-center md:justify-between gap-2">
            <div><h3 class="text-lg font-semibold dark:text-white">${escapeHTML(obj.header)}</h3><div class="text-xs text-gray-500 dark:text-gray-400 mono">${obj.length} aa • MW ${(obj.molecularWeight/1000).toFixed(2)} kDa</div>${parsingNote}</div>
            <div class="flex items-center gap-2 flex-wrap">
              <button class="text-xs bg-white dark:bg-slate-700 dark:border-slate-600 dark:text-slate-200 border border-slate-300 px-2.5 py-1.5 rounded-lg hover:bg-slate-50 dark:hover:bg-slate-600" data-copy-fasta="${obj.id}">Copy FASTA</button>
              <button class="text-xs bg-white dark:bg-slate-700 dark:border-slate-600 dark:text-slate-200 border border-slate-300 px-2.5 py-1.5 rounded-lg hover:bg-slate-50 dark:hover:bg-slate-600" data-download-svg="${obj.id}">Save map (SVG)</button>
              <button class="text-xs bg-slate-900 text-white px-2.5 py-1.5 rounded-lg hover:bg-black" data-export-props="${obj.id}">Export props (CSV)</button>
            </div>
          </div>
          <div class="mt-3"><h4 class="font-semibold text-sm mb-1 dark:text-slate-200">Graphical map (click to open fullscreen)</h4><div id="track-click-${obj.id}" class="group relative rounded-lg border border-gray-100 dark:border-slate-700 bg-gray-50 dark:bg-slate-900/50 p-2 hover:bg-gray-100 dark:hover:bg-slate-800 transition cursor-zoom-in"><div id="track-container-${obj.id}" class="w-full"></div><div class="absolute right-2 top-2 text-[11px] text-gray-500 opacity-80">Zoom in/out in fullscreen</div></div></div>
          <div class="grid grid-cols-1 lg:grid-cols-2 gap-3 mt-4">
            <div class="bg-gray-50 dark:bg-slate-900/30 border border-gray-100 dark:border-slate-700 rounded-xl p-3"><details class="text-sm font-medium" open><summary class="cursor-pointer font-semibold text-sm dark:text-slate-200">Residue statistics (${stats.total} aa)</summary><div class="h-28 overflow-y-auto mt-1 border-t dark:border-slate-700 pt-1 text-slate-700 dark:text-slate-300"><table class="w-full text-xs"><thead><tr><th class="dark:bg-slate-800 dark:text-slate-200">AA</th><th class="dark:bg-slate-800 dark:text-slate-200">N</th><th class="dark:bg-slate-800 dark:text-slate-200">%</th></tr></thead><tbody>${statsRows}</tbody></table></div></details></div>
            <div class="border border-gray-100 dark:border-slate-700 rounded-xl p-3 bg-white dark:bg-slate-800 h-56 overflow-y-auto" id="feature-list-${obj.id}">${buildFeatureListHTML(byLane)}</div>
          </div>
          <div class="grid grid-cols-1 lg:grid-cols-2 gap-3 mt-4">
            <div class="bg-gray-50 dark:bg-slate-900/50 border border-gray-100 dark:border-gray-700 rounded-xl p-3">
              <div class="grid grid-cols-2 gap-y-1 text-xs">
                <div>
                    <strong class="dark:text-slate-200">Theoretical pI:</strong> <span class="mono dark:text-slate-300" id="pi-val-${obj.id}">${obj.pI.toFixed(2)}</span>
                    <select class="text-[10px] border border-gray-300 dark:border-gray-600 rounded ml-1 bg-white text-slate-900 dark:bg-slate-800 dark:text-slate-100" id="pi-algo-${obj.id}" data-id="${obj.id}">
                        <option value="bjell">Bjellqvist (Expasy)</option>
                        <option value="emboss">EMBOSS</option>
                    </select>
                </div>
                <div><strong class="dark:text-slate-200">Net charge (pH ${Number(els.pH.value).toFixed(1)}):</strong> <span class="mono dark:text-slate-300">${obj.chargeAtPH.toFixed(2)}</span></div>
                <div><strong class="dark:text-slate-200">Aliphatic Index:</strong> <span class="mono dark:text-slate-300">${obj.aliphaticIndex.toFixed(2)}</span></div>
                <div><strong class="dark:text-slate-200">GRAVY:</strong> <span class="mono dark:text-slate-300">${obj.gravy.toFixed(3)}</span></div>
                <div class="col-span-2"><strong class="dark:text-slate-200">Instability:</strong> <span class="mono dark:text-slate-300">${obj.instability.toFixed(2)}</span> ${stabilityText}</div>
                <div class="col-span-2"><strong class="dark:text-slate-200">Formula:</strong> <span class="mono dark:text-slate-300 text-[10px] break-all">${obj.atomicFormula}</span></div>
                <div class="col-span-2"><strong class="dark:text-slate-200">Est. Half-life (${els.halfLifeOrg.value}):</strong> <span class="mono dark:text-slate-300">${obj.halfLife}</span></div>
              </div>
              <div class="mt-2 pt-2 border-t border-gray-200 dark:border-gray-700 text-xs">
                <div class="grid grid-cols-[170px,1fr] gap-y-1 items-center">
                  <div class="text-gray-500 dark:text-gray-400">State</div>
                  <select id="ext-state-${obj.id}" class="text-xs border border-gray-300 dark:border-gray-600 rounded p-0.5 bg-white text-slate-900 dark:bg-slate-800 dark:text-slate-100" data-id="${obj.id}">
                      <option value="unfolded">Unfolded (Edelhoch)</option>
                      <option value="folded">Folded (Guess +5%)</option>
                  </select>
                  <div class="text-gray-500 dark:text-gray-400">ε<sub>280</sub> (Tyr/Trp)</div><div class="mono dark:text-slate-300" id="ext-red-${obj.id}">${obj.extinction.reduced}</div>
                  <div class="text-gray-500 dark:text-gray-400">ε<sub>280</sub> (+cystines)</div><div class="mono dark:text-slate-300" id="ext-cys-${obj.id}">${obj.extinction.cystines}</div>
                </div>
              </div>
            </div>
            <div class="bg-white dark:bg-slate-800 border border-gray-100 dark:border-gray-700 rounded-xl p-3">
              <h4 class="font-semibold text-sm mb-2 dark:text-slate-200">A<sub>280</sub> helper</h4>
              <div class="grid grid-cols-3 gap-2 items-end">
                <div><label class="block text-xs dark:text-slate-300">Path length (cm)</label><input type="number" value="1" min="0.01" step="0.01" class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white text-slate-900 dark:bg-slate-900 dark:text-slate-100" placeholder="1.0" data-a280-path="${obj.id}"></div>
                <div><label class="block text-xs dark:text-slate-300">ε<sub>280</sub> type</label><select class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white text-slate-900 dark:bg-slate-900 dark:text-slate-100" data-a280-eps-type="${obj.id}"><option value="red">Reduced (Y+W)</option><option value="cys" selected>+Cystines</option></select></div>
                <div><label class="block text-xs dark:text-slate-300">A<sub>280</sub> (unitless)</label><input type="number" value="0" min="0" step="0.0001" class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white text-slate-900 dark:bg-slate-900 dark:text-slate-100" placeholder="e.g. 0.7" data-a280-A="${obj.id}"></div>
              </div>
              <div class="grid grid-cols-2 gap-2 mt-2">
                <div><label class="block text-xs dark:text-slate-300">Conc. (mg/mL)</label><input type="number" value="0" min="0" step="0.0001" class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white text-slate-900 dark:bg-slate-900 dark:text-slate-100" placeholder="0.0" data-a280-mgml="${obj.id}"></div>
                <div><label class="block text-xs dark:text-slate-300">Conc. (μM)</label><input type="number" value="0" min="0" step="0.0001" class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white text-slate-900 dark:bg-slate-900 dark:text-slate-100" placeholder="0.0" data-a280-um="${obj.id}"></div>
              </div>
              <div class="flex items-center gap-2 mt-2"><button class="text-xs bg-slate-900 text-white px-2.5 py-1.5 rounded-lg hover:bg-black border border-transparent" data-a280-calc="${obj.id}">Compute</button><div class="text-xs text-gray-700 dark:text-gray-300 flex items-end ml-auto"><span data-a280-out="${obj.id}"></span></div></div>
            </div>
          </div>
          <div class="mt-4">
             <details class="bg-indigo-50 dark:bg-indigo-900/20 border border-indigo-100 dark:border-indigo-800 rounded-xl p-3 text-sm">
                <summary class="cursor-pointer font-semibold text-indigo-900 dark:text-indigo-300">Lab Tools: Digestion & Mass Spec</summary>
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-4 mt-3">
                   <div>
                     <h5 class="font-bold text-xs uppercase text-gray-500 dark:text-gray-400 mb-2">In Silico Digestion</h5>
                     <div class="flex flex-wrap gap-2 mb-2" id="digest-checks-${obj.id}"></div>
                     <div class="flex flex-wrap gap-2">
                       <button class="text-xs bg-indigo-600 text-white px-3 py-1.5 rounded hover:bg-indigo-700" data-action="digest" data-id="${obj.id}">Digest</button>
                       <button class="text-xs bg-white dark:bg-slate-700 dark:border-slate-600 dark:text-slate-200 border border-indigo-200 text-indigo-800 px-3 py-1.5 rounded hover:bg-indigo-50 dark:hover:bg-slate-600" data-action="export-peptides" data-id="${obj.id}">Export CSV</button>
                       <button class="text-xs bg-emerald-600 text-white px-3 py-1.5 rounded hover:bg-emerald-700" data-action="mass-match" data-id="${obj.id}">Mass Matcher</button>
                     </div>
                     <div class="mt-2 max-h-60 overflow-y-auto border dark:border-slate-600 rounded bg-white dark:bg-slate-800">
                        <table class="lab-table" id="digest-table-${obj.id}"><thead><tr><th class="dark:bg-slate-800 dark:text-slate-200">Start</th><th class="dark:bg-slate-800 dark:text-slate-200">End</th><th class="dark:bg-slate-800 dark:text-slate-200">Seq</th><th class="dark:bg-slate-800 dark:text-slate-200">MW</th><th class="dark:bg-slate-800 dark:text-slate-200">pI</th></tr></thead><tbody class="dark:text-slate-300"><tr><td colspan="5" class="text-gray-400 text-center py-2">Select protease and click Digest</td></tr></tbody></table>
                     </div>
                   </div>
                   <div>
                     <h5 class="font-bold text-xs uppercase text-gray-500 dark:text-gray-400 mb-2">ESI Charge State Ladder</h5>
                     <div class="max-h-60 overflow-y-auto border dark:border-slate-600 rounded bg-white dark:bg-slate-800"><table class="lab-table" id="charge-table-container-${obj.id}"><caption class="text-xs text-left p-1 text-gray-500 dark:text-gray-400" id="charge-caption-${obj.id}">Whole Protein</caption><thead><tr><th class="dark:bg-slate-800 dark:text-slate-200">z</th><th class="dark:bg-slate-800 dark:text-slate-200">m/z (M+zH)<sup>z+</sup></th></tr></thead><tbody id="charge-table-${obj.id}" class="dark:text-slate-300"></tbody></table></div>
                     <div class="mt-2"><button class="text-xs bg-white dark:bg-slate-700 dark:text-slate-200 border border-gray-300 dark:border-slate-600 px-2 py-1 rounded hover:bg-gray-50 hidden" id="reset-charge-${obj.id}">Reset to Protein</button></div>
                   </div>
                </div>
             </details>
          </div>
          <details class="mt-4" id="plots-details-${obj.id}" ${plotsVisible ? 'open' : ''}><summary class="cursor-pointer font-semibold text-gray-800 dark:text-slate-200 mb-2">Plots & Analysis</summary><div id="plots-${obj.id}"></div></details>
        </div>
      </div>
    `;
    els.results.insertAdjacentHTML('beforeend', card);
    renderGraphicalMap(`track-container-${obj.id}`, byLane, obj.length, obj.seq);
    setupInteractions(obj.id, obj);
    wireA280Helper(obj);
    wirePerCardExports(obj);
    wireMapClickForModal(obj, byLane);
    wireLabTools(obj);
    wireNewFeatures(obj);
  }

  function wireNewFeatures(obj){
      // pI
      const piSel = document.getElementById(`pi-algo-${obj.id}`);
      piSel.addEventListener('change', () => {
          const val = isoelectricPoint(obj.counts, piSel.value);
          document.getElementById(`pi-val-${obj.id}`).textContent = val.toFixed(2);
      });

      // Extinction
      const extSel = document.getElementById(`ext-state-${obj.id}`);
      extSel.addEventListener('change', () => {
          const factor = extSel.value === 'folded' ? 1.05 : 1.0; // Simple heuristic
          const red = Math.round(obj.extinction.reduced * factor);
          const cys = Math.round(obj.extinction.cystines * factor);
          document.getElementById(`ext-red-${obj.id}`).textContent = red;
          document.getElementById(`ext-cys-${obj.id}`).textContent = cys;
      });
  }

  /* ===== Lab Tools Wiring ===== */
  function wireLabTools(obj){
    // Digestion
    const checksContainer = document.getElementById(`digest-checks-${obj.id}`);
    DEFS.PROTEASES.forEach(p => {
       const lbl = document.createElement('label');
       lbl.className = "flex items-center gap-1 text-xs bg-white text-slate-900 dark:bg-slate-900 dark:text-slate-200 border border-gray-200 dark:border-gray-600 rounded px-2 py-1 cursor-pointer hover:bg-gray-50 dark:hover:bg-slate-800";
       lbl.innerHTML = `<input type="checkbox" value="${p.name}" class="rounded text-indigo-600 focus:ring-indigo-500 dark:bg-slate-800 dark:border-gray-600"> ${p.name}`;
       checksContainer.appendChild(lbl);
    });

    const getPeptides = () => {
        const selected = Array.from(checksContainer.querySelectorAll('input:checked')).map(cb=>cb.value);
        if(!selected.length){ return { error: "Select at least one protease." }; }
        const cutSites = new Set([0, obj.length]);
        selected.forEach(pName => {
            const rule = DEFS.PROTEASES.find(x => x.name === pName);
            if(rule){
                const re = new RegExp(rule.regex);
                let m;
                while ((m = re.exec(obj.seq)) !== null) {
                    cutSites.add(m.index + m[0].length);
                    if (m[0].length === 0) re.lastIndex++;
                }
            }
        });
        const sortedSites = Array.from(cutSites).sort((a,b)=>a-b);
        const peptides = [];
        for(let i=0; i<sortedSites.length-1; i++){
            const start = sortedSites[i];
            const end = sortedSites[i+1];
            const seq = obj.seq.slice(start, end);
            const counts = countAA(seq);
            const mw = molecularWeight(counts);
            const pI = isoelectricPoint(counts);
            peptides.push({ start: start+1, end: end, seq, mw, pI });
        }
        return { peptides, selected };
    };

    const digestBtn = document.querySelector(`button[data-action="digest"][data-id="${obj.id}"]`);
    digestBtn.addEventListener('click', () => {
        const res = getPeptides();
        if(res.error) { alert(res.error); return; }
        const tableBody = document.getElementById(`digest-table-${obj.id}`).querySelector('tbody');
        tableBody.innerHTML = '';
        if(!res.peptides.length){ tableBody.innerHTML = '<tr><td colspan="5">No peptides generated.</td></tr>'; return; }
        res.peptides.forEach(p => {
            const row = `<tr><td class="mono text-xs border-b dark:border-slate-700">${p.start}</td><td class="mono text-xs border-b dark:border-slate-700">${p.end}</td><td class="mono text-xs max-w-[150px] truncate border-b dark:border-slate-700" title="${p.seq}">${p.seq}</td><td class="mono text-xs border-b dark:border-slate-700">${p.mw.toFixed(2)}</td><td class="mono text-xs border-b dark:border-slate-700">${p.pI.toFixed(2)}</td></tr>`;
            tableBody.insertAdjacentHTML('beforeend', row);
        });
    });

    const exportBtn = document.querySelector(`button[data-action="export-peptides"][data-id="${obj.id}"]`);
    exportBtn.addEventListener('click', () => {
        const res = getPeptides(); if(res.error) { alert(res.error); return; }
        const headerLines = [`Protein: ${obj.header}`, `Proteases: ${res.selected.join(' + ')}`, `Length: ${obj.length}`, ``, `Start,End,Sequence,MW,pI`].join('\n');
        const rows = res.peptides.map(p => `${p.start},${p.end},"${p.seq}",${p.mw.toFixed(2)},${p.pI.toFixed(2)}`).join('\n');
        downloadText(`${sanitizeName(obj.header)}_peptides.csv`, headerLines + '\n' + rows);
    });

    // Mass Matcher
    const matchBtn = document.querySelector(`button[data-action="mass-match"][data-id="${obj.id}"]`);
    matchBtn.addEventListener('click', () => {
        const userInput = prompt("Enter observed masses (space/comma separated):");
        if(!userInput) return;
        const masses = userInput.split(/[\s,]+/).map(parseFloat).filter(n => !isNaN(n));
        if(!masses.length) return;

        const tableBody = document.getElementById(`digest-table-${obj.id}`).querySelector('tbody');
        const rows = Array.from(tableBody.querySelectorAll('tr'));
        let found = 0;
        rows.forEach(row => {
            row.classList.remove('highlight-match');
            const mwCell = row.cells[3];
            if(mwCell){
                const mw = parseFloat(mwCell.textContent);
                // Check if any mass matches within 0.5 Da
                const isMatch = masses.some(m => Math.abs(m - mw) < 0.5);
                if(isMatch) { row.classList.add('highlight-match'); found++; }
            }
        });
        alert(`Highlighted ${found} matches.`);
    });

    updateChargeLadder(obj.id, obj.seq, obj.molecularWeight, "Whole Protein");
  }

  function updateChargeLadder(id, seq, mw, label){
    const tbody = document.getElementById(`charge-table-${id}`);
    const caption = document.getElementById(`charge-caption-${id}`);
    const resetBtn = document.getElementById(`reset-charge-${id}`);
    if(!tbody) return;
    if(label) caption.textContent = `${label} (MW: ${mw.toFixed(2)})`;
    const basicCount = 1 + Array.from(seq).filter(c => 'KRH'.includes(c)).length;
    const maxZ = Math.min(60, Math.max(3, basicCount)); 
    let rows = '';
    for(let z=1; z<=maxZ; z++){ const mz = (mw + z * 1.007276) / z; rows += `<tr><td class="mono font-semibold border-b dark:border-slate-700">+${z}</td><td class="mono border-b dark:border-slate-700">${mz.toFixed(2)}</td></tr>`; }
    tbody.innerHTML = rows;
    if(resetBtn) resetBtn.classList.toggle('hidden', label === "Whole Protein");
  }

  function renderGraphicalMap(containerId, byLane, seqLen, seq, vbWidth = 1000) {
    const container = document.getElementById(containerId);
    const laneOrder = Object.keys(byLane).sort();
    const hLane = 18, hSeq = 22, topPad = 5, leftPad = 80, rightPad = 10;
    const vbW = vbWidth;
    const height = (laneOrder.length * hLane) + hSeq + topPad + 24;
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', '100%'); svg.setAttribute('height', height); svg.setAttribute('viewBox', `0 0 ${vbW} ${height}`);
    svg.classList.add('feature-track-svg'); svg.dataset.seqLen = String(seqLen); svg.dataset.vbW = String(vbW); svg.dataset.leftPad = String(leftPad); svg.dataset.rightPad = String(rightPad);
    const step = (vbW - leftPad - rightPad) / Math.max(1, seqLen - 1);
    const xScale = (pos) => leftPad + step * pos;
    const seqY = topPad + laneOrder.length * hLane;
    const seqBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect'); seqBg.setAttribute('x', leftPad); seqBg.setAttribute('y', seqY); seqBg.setAttribute('height', hSeq); seqBg.setAttribute('width', vbW - leftPad - rightPad); seqBg.setAttribute('class', 'seq-bar-bg'); svg.appendChild(seqBg);
    const seqHighlight = document.createElementNS('http://www.w3.org/2000/svg', 'rect'); seqHighlight.setAttribute('y', seqY); seqHighlight.setAttribute('height', hSeq); seqHighlight.setAttribute('class', 'seq-bar-highlight'); seqHighlight.style.visibility = 'hidden'; svg.appendChild(seqHighlight);
    laneOrder.forEach((laneName, i) => {
      const y = topPad + i * hLane;
      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text'); text.setAttribute('x', 4); text.setAttribute('y', y + hLane/2 + 4); text.setAttribute('font-size', '10'); text.setAttribute('fill', '#4b5563'); text.textContent = laneName; svg.appendChild(text);
      byLane[laneName].forEach(f => {
        const r = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        r.dataset.start = f.start; r.dataset.end = f.end; r.dataset.name = f.name; r.dataset.category = laneName; r.dataset.match = f.match || ""; r.dataset.note = f.note || "";
        r.setAttribute('y', y + 2); r.setAttribute('height', hLane - 4); r.setAttribute('fill', f.color || '#94a3b8'); r.setAttribute('rx', '3'); r.setAttribute('x', xScale(f.start)); r.setAttribute('width', Math.max(2, step * (f.end - f.start + 1))); r.classList.add('feat-rect'); svg.appendChild(r);
      });
    });
    const axisY = seqY + hSeq;
    const ticksGroup = document.createElementNS('http://www.w3.org/2000/svg','g');
    for (let i = 0; i <= 10; i++) {
      const posIdx = Math.round(i * (seqLen - 1) / 10); const x = xScale(posIdx);
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line'); line.dataset.pos = posIdx; line.setAttribute('x1', x); line.setAttribute('x2', x); line.setAttribute('y1', axisY); line.setAttribute('y2', axisY + 4); line.setAttribute('stroke', '#9ca3af'); ticksGroup.appendChild(line);
      if (i > 0 && (seqLen > 50 ? i % 2 === 0 : true)) { const t = document.createElementNS('http://www.w3.org/2000/svg', 'text'); t.dataset.pos = posIdx; t.setAttribute('x', x); t.setAttribute('y', axisY + 14); t.setAttribute('text-anchor', 'middle'); t.setAttribute('font-size', '10'); t.setAttribute('fill', '#6b7280'); t.textContent = posIdx + 1; ticksGroup.appendChild(t); }
    }
    svg.appendChild(ticksGroup); container.appendChild(svg);
    // Tooltip logic
    function clientToSvgX(evt){ const pt = svg.createSVGPoint(); pt.x = evt.clientX; pt.y = evt.clientY; const wrap = svg.querySelector('g[data-zoom-wrap="1"]'); const matrix = wrap ? wrap.getScreenCTM() : svg.getScreenCTM(); if(!matrix) return 0; const local = pt.matrixTransform(matrix.inverse()); return local.x; }
    const allFeatures = []; Object.values(byLane).forEach(arr => arr.forEach(f => allFeatures.push(f)));
    svg.addEventListener('mousemove', e => {
      const vbW = parseFloat(svg.dataset.vbW), leftPad = parseFloat(svg.dataset.leftPad), rightPad = parseFloat(svg.dataset.rightPad);
      const step = (vbW - leftPad - rightPad) / Math.max(1, seqLen - 1);
      const localX = clientToSvgX(e);
      if (localX < leftPad || localX > vbW - rightPad) { els.tooltip.style.visibility = 'hidden'; return; }
      const pos = Math.round((localX - leftPad) / step);
      if (pos >= 0 && pos < seqLen) {
        const featsAtPos = allFeatures.filter(f => f.start <= pos && f.end >= pos);
        let html = `<strong>Pos: ${pos + 1}</strong>, AA: <span class="mono">${seq[pos]}</span>`;
        if (featsAtPos.length > 0) { html += '<br><span style="color:#f59e42;font-weight:600">Features:</span><ul style="margin:0;padding-left:1em">'; featsAtPos.forEach(f => { const match = f.match ? ` • <span class="mono" style="background:#1118271a;padding:1px 4px;border-radius:3px">${f.match}</span>` : ''; const note = f.note ? ` <span style="color:#cbd5e1">(${f.note})</span>` : ''; html += `<li><span style="color:${f.color||'#fff'}"><strong>${f.name}</strong></span> <span style="font-size:11px">[${f.category}, ${f.start+1}..${f.end+1}]</span>${match}${note}</li>`; }); html += '</ul>'; }
        els.tooltip.style.visibility = 'visible'; els.tooltip.innerHTML = html; els.tooltip.style.left = `${e.pageX + 10}px`; els.tooltip.style.top = `${e.pageY - 28}px`;
      }
    });
    svg.addEventListener('mouseleave', () => { els.tooltip.style.visibility = 'hidden'; });
    svg.querySelectorAll('.feat-rect').forEach(r => {
      r.addEventListener('mouseenter', (e) => { const start = parseInt(r.dataset.start), end = parseInt(r.dataset.end); highlightSvgRange(svg, start, end, true); const match = r.dataset.match ? ` • <span class="mono" style="background:#1118271a;padding:1px 4px;border-radius:3px">${r.dataset.match}</span>` : ''; const note = r.dataset.note ? ` <span style="color:#cbd5e1">(${r.dataset.note})</span>` : ''; els.tooltip.style.visibility = 'visible'; els.tooltip.innerHTML = `<strong>${r.dataset.name}</strong>${note}<br><span style="font-size:11px">${r.dataset.category} • ${start+1}..${end+1}</span>${match}`; els.tooltip.style.left = `${e.pageX + 10}px`; els.tooltip.style.top  = `${e.pageY - 28}px`; });
      r.addEventListener('mousemove', (e)=>{ els.tooltip.style.left = `${e.pageX + 10}px`; els.tooltip.style.top  = `${e.pageY - 28}px`; });
      r.addEventListener('mouseleave', () => { const start = parseInt(r.dataset.start), end = parseInt(r.dataset.end); highlightSvgRange(svg, start, end, false); els.tooltip.style.visibility = 'hidden'; });
    });
  }
  function toggleSvgRect(svg,start,end,on){ svg.querySelectorAll('.feat-rect').forEach(r=>{ if(parseInt(r.dataset.start)===start && parseInt(r.dataset.end)===end){ r.classList.toggle('highlight', on); } }); }
  function highlightSvgRange(svg,start,end,on){ const seqHighlight = svg.querySelector('.seq-bar-highlight'); const seqLen = parseInt(svg.dataset.seqLen, 10) || 1; const vbW = parseFloat(svg.dataset.vbW) || 1000; const leftPad = parseFloat(svg.dataset.leftPad) || 80; const rightPad = parseFloat(svg.dataset.rightPad) || 10; const step = (vbW - leftPad - rightPad) / Math.max(1, seqLen - 1); if (on) { const x1 = leftPad + step * start; const width = Math.max(1, step * (end - start + 1)); seqHighlight.setAttribute('x', x1); seqHighlight.setAttribute('width', width); seqHighlight.style.visibility = 'visible'; } else { seqHighlight.style.visibility = 'hidden'; } }
  function setupInteractions(id, obj) {
    const card = document.getElementById(`result-card-${id}`); const svg = card.querySelector('.feature-track-svg');
    card.querySelectorAll('.feature-list-item').forEach(item => {
      item.addEventListener('mouseenter', (ev) => { const start = parseInt(item.dataset.start), end = parseInt(item.dataset.end); highlightSvgRange(svg, start, end, true); toggleSvgRect(svg, start, end, true); item.classList.add('active'); const match = item.dataset.match ? ` • <span class="mono" style="background:#1118271a;padding:1px 4px;border-radius:3px">${item.dataset.match}</span>` : ''; const note = item.dataset.note ? ` <span style="color:#cbd5e1">(${item.dataset.note})</span>` : ''; els.tooltip.style.visibility = 'visible'; els.tooltip.innerHTML = `<strong>${item.dataset.name}</strong>${note}<br><span style="font-size:11px">${item.dataset.category} • ${start+1}.${end+1}</span>${match}`; els.tooltip.style.left = `${ev.pageX + 10}px`; els.tooltip.style.top = `${ev.pageY - 28}px`; });
      item.addEventListener('mousemove', (ev)=>{ els.tooltip.style.left = `${ev.pageX + 10}px`; els.tooltip.style.top  = `${ev.pageY - 28}px`; });
      item.addEventListener('mouseleave', () => { const start = parseInt(item.dataset.start), end = parseInt(item.dataset.end); highlightSvgRange(svg, start, end, false); toggleSvgRect(svg, start, end, false); item.classList.remove('active'); els.tooltip.style.visibility = 'hidden'; });
    });
  }
  function slidingWindowAvg(arr,w){ if(w<=1) return arr.slice(); const out = new Array(arr.length).fill(0); const halfBack = Math.floor((w - 1) / 2); const halfFwd = Math.ceil((w - 1) / 2); for(let i=0;i<arr.length;i++){ let s=0, n=0; for(let k=i-halfBack;k<=i+halfFwd;k++){ if(k>=0 && k<arr.length){ s+=arr[k]; n++; } } out[i] = n ? s/n : 0; } return out; }
  function getExtremes(arrays) { let min = Infinity, max = -Infinity; arrays.forEach(arr => { for(const v of arr) { if(isFinite(v)) { if(v < min) min = v; if(v > max) max = v; } } }); if(!isFinite(min)) min = 0; if(!isFinite(max)) max = 1; const range = max - min; if(range === 0) return { min: min - 0.5, max: max + 0.5 }; return { min: min - range * 0.05, max: max + range * 0.05 }; }
  function drawLinePlot(container, data, yMin, yMax, title, yLabel){
    const parent = document.getElementById(container); const wrap = document.createElement('div'); wrap.className = 'mini-chart-container'; const titleEl = document.createElement('div'); titleEl.className = 'chart-title'; titleEl.textContent = title + (yLabel ? ` (${yLabel})` : ''); wrap.appendChild(titleEl); const s = document.createElementNS('http://www.w3.org/2000/svg','svg'); s.classList.add('mini-chart'); parent.appendChild(wrap); wrap.appendChild(s);
    let W=600, H=150; const leftPad = 40, rightPad = 10, topPad = 10, botPad = 20; const hoverLine = document.createElementNS('http://www.w3.org/2000/svg','line'); hoverLine.setAttribute('class','hover-line'); hoverLine.style.visibility='hidden'; s.appendChild(hoverLine);
    function xScale(x){ return leftPad + (x * (W-leftPad-rightPad)) / Math.max(1, (Array.isArray(data[0]) ? data[0].length : data.length)-1); }
    function yScale(y){ return topPad + (H-topPad-botPad) * (1 - (y - yMin) / (yMax - yMin)); }
    function render(){
      const rect = s.getBoundingClientRect(); W = rect.width || parent.clientWidth || 600; H = rect.height || 150; s.setAttribute('viewBox', `0 0 ${W} ${H}`); while(s.firstChild) s.removeChild(s.firstChild); s.appendChild(hoverLine);
      for(let i=0;i<=4;i++){ const yVal = yMin + (i*(yMax-yMin))/4; const y = yScale(yVal); const line = document.createElementNS('http://www.w3.org/2000/svg','line'); line.setAttribute('x1', leftPad); line.setAttribute('x2', W-rightPad); line.setAttribute('y1', y); line.setAttribute('y2', y); line.setAttribute('stroke', '#e5e7eb'); s.appendChild(line); const text = document.createElementNS('http://www.w3.org/2000/svg','text'); text.setAttribute('x', 2); text.setAttribute('y', y+3); text.setAttribute('font-size','10'); text.setAttribute('fill','#6b7280'); text.textContent = yVal.toFixed(1); s.appendChild(text); }
      if(Array.isArray(data[0])){ const colors = ['#2563eb', '#dc2626']; data.forEach((series, idx) => { const pts = series.map((v,i)=> `${xScale(i)},${isFinite(v) ? yScale(v) : yScale(0)}`).join(' '); const pl = document.createElementNS('http://www.w3.org/2000/svg','polyline'); pl.setAttribute('fill','none'); pl.setAttribute('stroke', colors[idx % colors.length]); pl.setAttribute('stroke-width','1.5'); pl.setAttribute('points', pts); s.appendChild(pl); }); } else { const pts = data.map((v,i)=> `${xScale(i)},${isFinite(v) ? yScale(v) : yScale(0)}`).join(' '); const pl = document.createElementNS('http://www.w3.org/2000/svg','polyline'); pl.setAttribute('fill','none'); pl.setAttribute('stroke','#2563eb'); pl.setAttribute('stroke-width','1.5'); pl.setAttribute('points', pts); s.appendChild(pl); }
      for(let i=0;i<=10;i++){ const idx = Math.round(i*(data.length || data[0].length-1)/10); const x = xScale(idx); const l = document.createElementNS('http://www.w3.org/2000/svg','line'); l.setAttribute('x1', x); l.setAttribute('x2', x); l.setAttribute('y1', H-botPad); l.setAttribute('y2', H-botPad+4); l.setAttribute('stroke','#9ca3af'); s.appendChild(l); if(i%2===0 && idx>0){ const t = document.createElementNS('http://www.w3.org/2000/svg','text'); t.setAttribute('x', x); t.setAttribute('y', H-2); t.setAttribute('text-anchor','middle'); t.setAttribute('font-size','10'); t.setAttribute('fill','#6b7280'); t.textContent = idx+1; s.appendChild(t); } }
    }
    s.addEventListener('mousemove', e=>{ const rect = s.getBoundingClientRect(); const x = e.clientX - rect.left; if(x < 40 || x > rect.width - 10){ hoverLine.style.visibility='hidden'; els.tooltip.style.visibility='hidden'; return; } hoverLine.setAttribute('x1', x); hoverLine.setAttribute('x2', x); hoverLine.setAttribute('y1', 10); hoverLine.setAttribute('y2', 150 - 20); hoverLine.style.visibility='visible'; const len = Array.isArray(data[0]) ? data[0].length : data.length; const pos = Math.round((x - 40) / ((rect.width-40-10)/Math.max(1,len-1))); if(pos>=0 && pos<len){ let valStr = ''; if(Array.isArray(data[0])){ valStr = data.map((d,i) => `<span style="color:${i===0?'blue':'red'}">${isFinite(d[pos]) ? d[pos].toFixed(2) : 'NaN'}</span>`).join(' vs '); } else { valStr = isFinite(data[pos]) ? data[pos].toFixed(2) : 'NaN'; } els.tooltip.style.visibility = 'visible'; els.tooltip.innerHTML = `Pos: ${pos+1}<br>Value: ${valStr}`; els.tooltip.style.left = `${e.pageX + 10}px`; els.tooltip.style.top  = `${e.pageY - els.tooltip.offsetHeight - 5}px`; } });
    s.addEventListener('mouseleave', ()=>{ hoverLine.style.visibility='hidden'; els.tooltip.style.visibility='hidden'; });
    render(); new ResizeObserver(()=>render()).observe(parent);
  }
  function drawCysTrack(container, seq){ const parent = document.getElementById(container); const titleEl = document.createElement('div'); titleEl.className = 'chart-title'; titleEl.textContent = 'Cysteine positions'; parent.appendChild(titleEl); const s = document.createElementNS('http://www.w3.org/2000/svg','svg'); s.classList.add('mini-track'); parent.appendChild(s); const positions = []; for(let i=0;i<seq.length;i++) if(seq[i]==='C') positions.push(i); function render(){ const rect = s.getBoundingClientRect(); const W = rect.width || parent.clientWidth || 600; const H = 40; s.setAttribute('viewBox', `0 0 ${W} ${H}`); while(s.firstChild) s.removeChild(s.firstChild); if(positions.length===0){ const text = document.createElementNS('http://www.w3.org/2000/svg','text'); text.setAttribute('x', 4); text.setAttribute('y', 22); text.setAttribute('font-size','12'); text.setAttribute('fill','#6b7280'); text.textContent = 'No cysteines found'; s.appendChild(text); return; } const leftPad=10, rightPad=10; const step = (W-leftPad-rightPad)/Math.max(1, seq.length-1); const xScale = idx => leftPad + step * idx; positions.forEach(idx=>{ const c = document.createElementNS('http://www.w3.org/2000/svg','circle'); c.setAttribute('cx', xScale(idx)); c.setAttribute('cy', 20); c.setAttribute('r', 4); c.setAttribute('fill', '#059669'); c.addEventListener('mouseenter', (e)=>{ els.tooltip.style.visibility='visible'; els.tooltip.innerHTML = `<strong>Cys</strong> at position <span class="mono">${idx+1}</span>`; els.tooltip.style.left = `${e.pageX + 10}px`; els.tooltip.style.top  = `${e.pageY - 28}px`; }); c.addEventListener('mousemove', (e)=>{ els.tooltip.style.left = `${e.pageX + 10}px`; els.tooltip.style.top  = `${e.pageY - 28}px`; }); c.addEventListener('mouseleave', ()=>{ els.tooltip.style.visibility='hidden'; }); s.appendChild(c); }); } render(); new ResizeObserver(()=>render()).observe(parent); }
  function drawScatterPlot(container, dataX, dataY, nameX, nameY) { const parent = document.getElementById(container); parent.innerHTML = ''; const W = 500, H = 400; const margin = { top: 20, right: 30, bottom: 40, left: 50 }; const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg'); svg.setAttribute('viewBox', `0 0 ${W} ${H}`); svg.style.maxWidth = '100%'; svg.style.height = 'auto'; svg.style.border = '1px solid #e5e7eb'; svg.style.backgroundColor = '#fff'; parent.appendChild(svg); const extX = getExtremes([dataX]); const extY = getExtremes([dataY]); const xScale = v => margin.left + (v - extX.min) / (extX.max - extX.min) * (W - margin.left - margin.right); const yScale = v => H - margin.bottom - (v - extY.min) / (extY.max - extY.min) * (H - margin.top - margin.bottom); const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line'); xAxis.setAttribute('x1', margin.left); xAxis.setAttribute('x2', W - margin.right); xAxis.setAttribute('y1', H - margin.bottom); xAxis.setAttribute('y2', H - margin.bottom); xAxis.setAttribute('stroke', '#000'); svg.appendChild(xAxis); const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line'); yAxis.setAttribute('x1', margin.left); yAxis.setAttribute('x2', margin.left); yAxis.setAttribute('y1', margin.top); yAxis.setAttribute('y2', H - margin.bottom); yAxis.setAttribute('stroke', '#000'); svg.appendChild(yAxis); const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text'); xLabel.setAttribute('x', W / 2); xLabel.setAttribute('y', H - 5); xLabel.setAttribute('text-anchor', 'middle'); xLabel.setAttribute('font-size', '12'); xLabel.textContent = nameX; svg.appendChild(xLabel); const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text'); yLabel.setAttribute('transform', `translate(15, ${H/2}) rotate(-90)`); yLabel.setAttribute('text-anchor', 'middle'); yLabel.setAttribute('font-size', '12'); yLabel.textContent = nameY; svg.appendChild(yLabel); const g = document.createElementNS('http://www.w3.org/2000/svg', 'g'); svg.appendChild(g); const colorAt = i => `hsl(${Math.round(i / dataX.length * 360)}, 70%, 50%)`; for(let i=0; i<dataX.length; i++){ const cx = xScale(dataX[i]); const cy = yScale(dataY[i]); const c = document.createElementNS('http://www.w3.org/2000/svg', 'circle'); c.setAttribute('cx', cx); c.setAttribute('cy', cy); c.setAttribute('r', 3); c.setAttribute('fill', colorAt(i)); c.setAttribute('opacity', '0.6'); c.addEventListener('mouseenter', e => { c.setAttribute('r', 6); c.setAttribute('opacity', '1'); els.tooltip.style.visibility='visible'; els.tooltip.innerHTML = `<strong>Pos ${i+1}</strong><br>${nameX}: ${dataX[i].toFixed(2)}<br>${nameY}: ${dataY[i].toFixed(2)}`; els.tooltip.style.left = `${e.pageX + 10}px`; els.tooltip.style.top  = `${e.pageY - 28}px`; }); c.addEventListener('mousemove', e => { els.tooltip.style.left = `${e.pageX + 10}px`; els.tooltip.style.top  = `${e.pageY - 28}px`; }); c.addEventListener('mouseleave', e => { c.setAttribute('r', 3); c.setAttribute('opacity', '0.6'); els.tooltip.style.visibility='hidden'; }); g.appendChild(c); } }
  function refreshAllPlots(){ currentResults.forEach(o=>updatePlotsForCard(o)); }
  function refreshCharges(){ currentResults.forEach(o=>{ const c = netCharge(o.counts, Number(els.pH.value)); const card = document.getElementById(`result-card-${o.id}`); const target = card.querySelector('.grid.grid-cols-2 div:nth-child(2) span.mono'); if(target) target.textContent = c.toFixed(2); if(els.optCharge.checked) updatePlotsForCard(o); }); }
  function refreshAllCards(){
      // 1. Gather enabled categories (Feature Filtering)
      const enabled = new Set();
      if(els.featTopology.checked) enabled.add('Topology');
      if(els.featPtm.checked) enabled.add('PTM');
      if(els.featLocal.checked) enabled.add('Localization');
      if(els.featTags.checked) { enabled.add('Tags & Sites'); enabled.add('Site'); }
      if(els.featDomain.checked) { enabled.add('Domain'); enabled.add('Degron'); enabled.add('Large Domain'); }
      if(els.featUser.checked) enabled.add('User Domains');

      currentResults = currentResults.map(o => {
          const tmSegs = transmembranes(o.seq, parseInt(els.tmWindow.value,10), Number(els.tmThr.value));
          const spSegs = signalPeptideCandidates(o.seq);
          const motifSegs = scanFeatures(o.seq);

          let all = mergeSegments([ ...tmSegs, ...spSegs, ...motifSegs ]);

          // Filter by enabled categories
          all = all.filter(f => enabled.has(f.category));

          o.features = all;
          o.halfLife = estimatedHalfLife(o.seq, els.halfLifeOrg.value);
          return o;
      });

      currentResults.forEach(o => {
          const card = document.getElementById(`result-card-${o.id}`);
          if(!card) return;
          const list = card.querySelector(`#feature-list-${o.id}`);
          const byLane = o.features.reduce((acc, f) => { (acc[f.category] = acc[f.category] || []).push(f); return acc; }, {});
          list.innerHTML = buildFeatureListHTML(byLane);
          const track = card.querySelector(`#track-container-${o.id}`);
          track.innerHTML = '';
          renderGraphicalMap(`track-container-${o.id}`, byLane, o.length, o.seq);
          setupInteractions(o.id, o);
          updatePlotsForCard(o);
      });
  }
  function getPlotArray(obj, type) { if(type === 'hydro') { const raw = Array.from(obj.seq, a => AA.kd[a] ?? 0); return slidingWindowAvg(raw, parseInt(els.hydroWindow.value, 10)); } if(type === 'charge') { const arr = perResidueChargeArray(obj.seq, Number(els.pH.value)); return slidingWindowAvg(arr, parseInt(els.chargeWindow.value, 10)); } if(type === 'disorder') { const win = 15; const hRaw = Array.from(obj.seq, a => ( (AA.kd[a]??0) + 4.5)/9.0 ); const qArr = perResidueChargeArray(obj.seq, 7.0); const score = []; const half = Math.floor(win/2); for(let i=0; i<obj.length; i++){ let sumH=0, sumQ=0, n=0; for(let k=i-half; k<=i+half; k++){ if(k>=0 && k<obj.length){ sumH += hRaw[k]; sumQ += qArr[k]; n++; } } if(n>0) score.push( 2.785*(sumH/n) - Math.abs(sumQ/n) - 1.151 ); else score.push(0); } return score; } if(type === 'moment') { const angle = 100 * (Math.PI/180); const win = 11; const moments = []; const hRaw = Array.from(obj.seq, a => AA.kd[a] ?? 0); for(let i=0; i<obj.length; i++){ if(i + win > obj.length){ moments.push(0); continue; } let sumC=0, sumS=0; for(let k=0; k<win; k++){ const h = hRaw[i+k]; sumC += h * Math.cos(k * angle); sumS += h * Math.sin(k * angle); } moments.push( Math.sqrt(sumC*sumC + sumS*sumS) / win ); } const shifted = new Array(obj.length).fill(0); const offset = Math.floor(win/2); for(let i=0; i<moments.length; i++){ if(i+offset < shifted.length) shifted[i+offset] = moments[i]; } return shifted; } if(type === 'helix') { const def = DEFS.CHOU_FASMAN; if(!def) return new Array(obj.length).fill(0); const pH = []; for(const aa of obj.seq) pH.push(def[aa] ? def[aa].H : 100); return slidingWindowAvg(pH, 6); } if(type === 'sheet') { const def = DEFS.CHOU_FASMAN; if(!def) return new Array(obj.length).fill(0); const pE = []; for(const aa of obj.seq) pE.push(def[aa] ? def[aa].E : 100); return slidingWindowAvg(pE, 5); } return new Array(obj.length).fill(0); }
  function updatePlotsForCard(obj){ const contId = `plots-${obj.id}`; const cont = document.getElementById(contId); if(!cont) return; cont.innerHTML = ""; if(els.optHydro.checked){ const data = getPlotArray(obj, 'hydro'); const range = getExtremes([data]); const holder = document.createElement('div'); holder.id = `${contId}-hydro`; cont.appendChild(holder); drawLinePlot(holder.id, data, range.min, range.max, 'Hydrophobicity (Kyte–Doolittle)', 'KD'); } if(els.optCharge.checked){ const data = getPlotArray(obj, 'charge'); const range = getExtremes([data]); const holder = document.createElement('div'); holder.id = `${contId}-charge`; cont.appendChild(holder); drawLinePlot(holder.id, data, range.min, range.max, `Charge per residue (pH ${Number(els.pH.value).toFixed(1)})`, 'charge'); } if(els.optDisorder.checked){ const data = getPlotArray(obj, 'disorder'); const range = getExtremes([data]); const holder = document.createElement('div'); holder.id = `${contId}-disorder`; cont.appendChild(holder); drawLinePlot(holder.id, data, range.min, range.max, 'Folding Index (Pos=Folded, Neg=Disordered)', 'Score'); } if(els.optSecStruct.checked){ const sH = getPlotArray(obj, 'helix'); const sE = getPlotArray(obj, 'sheet'); const range = getExtremes([sH, sE]); const holder = document.createElement('div'); holder.id = `${contId}-secstruct`; cont.appendChild(holder); drawLinePlot(holder.id, [sH, sE], range.min, range.max, 'Sec. Struct Propensity (Blue=Helix, Red=Sheet)', 'Propensity'); } if(els.optMoment.checked){ const data = getPlotArray(obj, 'moment'); const range = getExtremes([data]); const holder = document.createElement('div'); holder.id = `${contId}-moment`; cont.appendChild(holder); drawLinePlot(holder.id, data, range.min, range.max, 'Hydrophobic Moment (α-helix, 100°)', 'µH'); } if(els.optCys.checked){ const holder = document.createElement('div'); holder.id = `${contId}-cys`; cont.appendChild(holder); drawCysTrack(holder.id, obj.seq); } const twoDContainer = document.createElement('div'); twoDContainer.className = "mt-6 border-t pt-4"; twoDContainer.innerHTML = `<h4 class="font-semibold text-sm mb-2 dark:text-slate-200">2D Analysis</h4><div class="flex flex-wrap items-center gap-3 mb-3"><select id="x-axis-${obj.id}" class="p-2 border rounded text-sm bg-white dark:bg-slate-800 dark:border-slate-600 dark:text-slate-200"><option value="hydro" selected>Hydrophobicity</option><option value="charge">Charge</option><option value="disorder">Disorder</option><option value="moment">Hydrophobic Moment</option><option value="helix">Helix Propensity</option><option value="sheet">Sheet Propensity</option></select><span class="text-gray-500 font-bold">vs</span><select id="y-axis-${obj.id}" class="p-2 border rounded text-sm bg-white dark:bg-slate-800 dark:border-slate-600 dark:text-slate-200"><option value="hydro">Hydrophobicity</option><option value="charge" selected>Charge</option><option value="disorder">Disorder</option><option value="moment">Hydrophobic Moment</option><option value="helix">Helix Propensity</option><option value="sheet">Sheet Propensity</option></select><button id="plot-2d-btn-${obj.id}" class="bg-indigo-600 text-white text-xs px-3 py-2 rounded hover:bg-indigo-700">Plot 2D</button></div><div id="plot-2d-area-${obj.id}" class="w-full max-w-lg mx-auto"></div>`; cont.appendChild(twoDContainer); document.getElementById(`plot-2d-btn-${obj.id}`).addEventListener('click', () => { const xType = document.getElementById(`x-axis-${obj.id}`).value; const yType = document.getElementById(`y-axis-${obj.id}`).value; const xData = getPlotArray(obj, xType); const yData = getPlotArray(obj, yType); drawScatterPlot(`plot-2d-area-${obj.id}`, xData, yData, xType, yType); }); }
  function calcAFromMgml(eps, mw, mgml, path){ if(!(eps>0 && mw>0 && path>0 && mgml>=0)) return NaN; return (eps / mw) * mgml * path; }
  function calcAFromuM(eps, uM, path){ if(!(eps>0 && path>0 && uM>=0)) return NaN; return eps * (uM * 1e-6) * path; }
  function concFromA({ A=0, path=1.0, eps=0, mw=1 }){ if(!(eps>0 && path>0 && mw>0 && A>=0)) return { mgml: NaN, uM: NaN }; const mgml = A / ((eps / mw) * path); const uM = (A / (eps * path)) * 1e6; return { mgml, uM }; }
  function wireA280Helper(obj){
    const card = document.getElementById(`result-card-${obj.id}`); const pathEl = card.querySelector(`[data-a280-path="${obj.id}"]`); const epsSel = card.querySelector(`[data-a280-eps-type="${obj.id}"]`); const mgEl = card.querySelector(`[data-a280-mgml="${obj.id}"]`); const umEl = card.querySelector(`[data-a280-um="${obj.id}"]`); const aEl = card.querySelector(`[data-a280-A="${obj.id}"]`); const outEl = card.querySelector(`[data-a280-out="${obj.id}"]`); const btn = card.querySelector(`[data-a280-calc="${obj.id}"]`);
    function chosenEps(){ return (epsSel.value === 'cys') ? obj.extinction.cystines : obj.extinction.reduced; }
    function show(msg){ outEl.textContent = msg; }
    btn.addEventListener('click', ()=>{ const path = Number(pathEl.value); const A = Number(aEl.value); const eps = chosenEps(); if(!isFinite(path) || !isFinite(A) || path<=0 || A<0 || !isFinite(eps) || eps<=0){ show("Invalid inputs."); return; } const { mgml, uM } = concFromA({A, path, eps, mw: obj.molecularWeight}); mgEl.value = isFinite(mgml) ? mgml.toFixed(6) : ''; umEl.value = isFinite(uM) ? uM.toFixed(3) : ''; show(`From A=${A}: ${isFinite(mgml)?mgml.toFixed(6):'—'} mg/mL • ${isFinite(uM)?uM.toFixed(3):'—'} μM`); });
    [pathEl, epsSel, mgEl, umEl].forEach(el=>{ el.addEventListener('change', ()=>{ const eps = chosenEps(); const path = Number(pathEl.value); const mgml = Number(mgEl.value); const um = Number(umEl.value); if (isFinite(mgml) && mgml>0 && isFinite(eps) && eps>0 && isFinite(path) && path>0){ const A = calcAFromMgml(eps, obj.molecularWeight, mgml, path); if (isFinite(A)) aEl.value = A.toFixed(5); } else if (isFinite(um) && um>0 && isFinite(eps) && eps>0 && isFinite(path) && path>0){ const A = calcAFromuM(eps, um, path); if (isFinite(A)) aEl.value = A.toFixed(5); } }); });
  }
  function wirePerCardExports(obj){
    const card = document.getElementById(`result-card-${obj.id}`); const svgBtn = card.querySelector(`[data-download-svg="${obj.id}"]`); const copyBtn = card.querySelector(`[data-copy-fasta="${obj.id}"]`); const propsBtn = card.querySelector(`[data-export-props="${obj.id}"]`);
    svgBtn.addEventListener('click', ()=>{ const svg = card.querySelector('.feature-track-svg'); if(!svg){ alert('Map not available.'); return; } const cloned = svg.cloneNode(true); const s = new XMLSerializer().serializeToString(cloned); const blob = new Blob([s], {type:'image/svg+xml;charset=utf-8'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `${sanitizeName(obj.header)}_map.svg`; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(url), 500); });
    copyBtn.addEventListener('click', async ()=>{ const text = `>${obj.header}\n${obj.seq.replace(/(.{1,80})/g, '$1\n').trim()}\n`; try{ await navigator.clipboard.writeText(text); copyBtn.textContent='Copied'; setTimeout(()=>copyBtn.textContent='Copy FASTA', 1200); }catch{ alert('Clipboard failed.'); } });
    propsBtn.addEventListener('click', ()=>{ const rows = [ ['Header', obj.header], ['Length', obj.length], ['MolecularWeight_Da', obj.molecularWeight.toFixed(2)], ['Theoretical_pI', obj.pI.toFixed(3)], ['Charge_at_pH_'+Number(els.pH.value).toFixed(1), obj.chargeAtPH.toFixed(3)], ['GRAVY_KD', obj.gravy.toFixed(4)], ['Aliphatic_Index', obj.aliphaticIndex.toFixed(2)], ['Instability_Index', obj.instability.toFixed(2)], ['Atomic_Formula', obj.atomicFormula], ['Half_Life', obj.halfLife], ['E280_reduced', obj.extinction.reduced], ['E280_plus_cystines', obj.extinction.cystines] ]; const csv = rows.map(r=>r.map(x=>`"${String(x).replace(/"/g,'""')}"`).join(',')).join('\n'); downloadText(`${sanitizeName(obj.header)}_props.csv`, csv); });
  }
  function sanitizeName(s){ return s.replace(/[^\w\d\-_.]+/g,'_').slice(0,120)||'sequence'; }
  function downloadText(filename, text){ const blob = new Blob([text], {type:'text/plain;charset=utf-8'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(url), 500); }
  els.exportAllCsv.addEventListener('click', ()=>{ if(currentResults.length===0){ alert('No results to export.'); return; } const header = ['Header','Length','MW_Da','pI','Charge_at_pH_'+Number(els.pH.value).toFixed(1),'GRAVY','Aliphatic','Instability','HalfLife','Formula','E280_red','E280_cys']; const rows = currentResults.map(o=>[ o.header,o.length,o.molecularWeight.toFixed(2),o.pI.toFixed(3),netCharge(o.counts, Number(els.pH.value)).toFixed(3), o.gravy.toFixed(4),o.aliphaticIndex.toFixed(2),o.instability.toFixed(2),o.halfLife,o.atomicFormula, o.extinction.reduced,o.extinction.cystines ]); const csv = [header, ...rows].map(r=>r.map(x=>`"${String(x).replace(/"/g,'""')}"`).join(',')).join('\n'); downloadText('protein_workbench_summary.csv', csv); });
  els.toggleAllPlots.addEventListener('click', ()=>{ plotsVisible = !plotsVisible; currentResults.forEach(o=>{ const details = document.getElementById(`plots-details-${o.id}`); if(!details) return; details.open = plotsVisible; }); });
  els.expandAll.addEventListener('click', ()=>{ document.querySelectorAll('#results_section details').forEach(d=>d.open=true); });
  els.collapseAll.addEventListener('click', ()=>{ document.querySelectorAll('#results_section details').forEach(d=>d.open=false); });
  function wireMapClickForModal(obj, byLane){ const clickBox = document.getElementById(`track-click-${obj.id}`); clickBox.addEventListener('click', ()=>{ openMapModal(obj, byLane); }, { passive: true }); }
  let _modalResizeHandler = null; const MODAL_VB_WIDTH = 2400;
  function _sizeModalToViewport(){ const modal = els.modal; const modalContent = modal.querySelector('.map-modal-content'); const headerEl = modal.querySelector('.map-modal-header'); const bodyEl = els.modalBody; modalContent.style.width = '98vw'; modalContent.style.maxWidth = '98vw'; modalContent.style.height = '96vh'; modalContent.style.maxHeight = '96vh'; const headerH = headerEl ? headerEl.offsetHeight : 56; const paddingAllowance = 16; const bodyH = Math.max(300, modalContent.clientHeight - headerH - paddingAllowance); bodyEl.style.height = bodyH + 'px'; bodyEl.style.minHeight = bodyH + 'px'; const svg = bodyEl.querySelector('svg'); if (svg) { svg.style.width = '100%'; svg.style.height = (bodyH - 4) + 'px'; } }
  function openMapModal(obj, byLane){ els.modalBody.innerHTML = ''; els.modal.classList.add('open'); els.modal.setAttribute('aria-hidden','false'); _sizeModalToViewport(); const holder = document.createElement('div'); holder.id = `modal-track-${obj.id}`; holder.style.width = '100%'; holder.style.height = '100%'; els.modalBody.appendChild(holder); renderGraphicalMap(holder.id, byLane, obj.length, obj.seq, MODAL_VB_WIDTH); const svg = holder.querySelector('svg'); const vbH = svg.viewBox.baseVal.height; svg.style.width = '100%'; svg.style.height = '100%'; svg.style.display = 'block'; let wrap = svg.querySelector('g[data-zoom-wrap="1"]'); if (!wrap) { wrap = document.createElementNS('http://www.w3.org/2000/svg','g'); wrap.setAttribute('data-zoom-wrap','1'); while (svg.firstChild) wrap.appendChild(svg.firstChild); svg.appendChild(wrap); } if (window.d3 && d3.zoom) { const zoom = d3.zoom().scaleExtent([1, 20]).translateExtent([[0, 0], [MODAL_VB_WIDTH, vbH]]).on('zoom', (event)=> d3.select(wrap).attr('transform', event.transform)); d3.select(svg).on('.zoom', null).call(zoom); modalState.svg = svg; modalState.zoom = zoom; } else { modalState.svg = null; modalState.zoom = null; } _modalResizeHandler = () => _sizeModalToViewport(); window.addEventListener('resize', _modalResizeHandler, { passive: true }); }
  function closeMapModal(){ els.modal.classList.remove('open'); els.modal.setAttribute('aria-hidden','true'); els.modalBody.innerHTML = ''; if (_modalResizeHandler) { window.removeEventListener('resize', _modalResizeHandler); _modalResizeHandler = null; } modalState = { svg:null, zoom:null }; }
  els.modalClose.addEventListener('click', closeMapModal); els.modal.addEventListener('click', (e)=>{ if (e.target === els.modal) closeMapModal(); }); document.addEventListener('keydown', (e)=>{ if(e.key === 'Escape' && els.modal.classList.contains('open')) closeMapModal(); }); els.modalReset.addEventListener('click', ()=>{ if (modalState.svg && modalState.zoom) { d3.select(modalState.svg).transition().duration(200).call(modalState.zoom.transform, d3.zoomIdentity); } });
};
</script>

<script>
(function(){
  function loadDefs() {
    if (window.PROTEIN_DEFS && window.PROTEIN_UTILS) return Promise.resolve();
    return new Promise((resolve, reject) => {
      const s = document.createElement('script');
      s.src = 'definitions.js';
      s.onload = () => {
        if(window.PROTEIN_DEFS) resolve();
        else reject(new Error("definitions.js loaded but PROTEIN_DEFS missing"));
      };
      s.onerror = () => reject(new Error("Failed to load definitions.js"));
      document.head.appendChild(s);
    });
  }

  loadDefs().then(() => {
    if (typeof window.initProteinWorkbench === 'function') {
      window.initProteinWorkbench();
    }
  }).catch(err => {
    console.error(err);
    alert("Error: " + err.message);
  });
})();
</script>
