<style>
    .input-group { display: flex; align-items: center; }
    .input-group input { border-top-right-radius: 0; border-bottom-right-radius: 0; flex-grow: 1; }
    .input-group select { border-top-left-radius: 0; border-bottom-left-radius: 0; border-left: 0; }
    .prose strong { color: #4f46e5; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .btn { @apply bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg shadow-lg focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500; }
    .btn-secondary { @apply bg-gray-800 hover:bg-black text-white font-semibold py-2 px-4 rounded-lg; }
</style>

<div class="container mx-auto p-4 md:p-8 max-w-7xl">
  <header class="text-center mb-8">
    <h1 class="text-4xl font-bold text-gray-900">Binding Equilibrium Calculator</h1>
    <p class="mt-2 text-lg text-gray-600">Compute equilibrium for two rigorous models and visualize saturation curves.</p>
  </header>

  <div class="grid grid-cols-1 lg:grid-cols-5 gap-8">
    <div class="lg:col-span-2 space-y-8">
      <div class="bg-white p-6 rounded-xl shadow-lg space-y-4">
        <h2 class="text-2xl font-semibold text-gray-800 border-b pb-3">Inputs</h2>

        <div>
          <label class="block text-sm font-medium text-gray-700 mb-1">Model</label>
          <select id="model" class="w-full px-3 py-2 bg-white border border-gray-300 rounded-md">
            <option value="single_step" selected>Single-step n-mer assembly: P1 + n·P2 ⇌ P1·(P2)<sub>n</sub></option>
            <option value="stepwise_identical">Stepwise binding, n identical independent sites on P1</option>
          </select>
          <p class="text-xs text-gray-500 mt-1">
            Choose “single-step” only for true one-step assemblies. Choose “stepwise” for typical multi-site binding.
          </p>
        </div>

        <div>
          <label for="stoichiometry" class="block text-sm font-medium text-gray-700 mb-1">Stoichiometry n (integer)</label>
          <input type="number" id="stoichiometry" value="1" min="1" step="1"
                 class="w-full px-3 py-2 bg-white border border-gray-300 rounded-md">
          <p class="text-xs text-gray-500 mt-1">n is the number of P2 molecules per P1 in the fully bound state.</p>
        </div>

        <div>
          <label for="protein1_conc" class="block text-sm font-medium text-gray-700 mb-1">Protein 1 Total</label>
          <div class="input-group">
            <input type="number" id="protein1_conc" value="10"
                   class="w-full px-3 py-2 bg-white border border-gray-300 rounded-md" />
            <select id="protein1_units" class="px-3 py-2 border-gray-300 rounded-md bg-white">
              <option value="nM" selected>nM</option>
              <option value="uM">µM</option>
              <option value="mM">mM</option>
            </select>
          </div>
        </div>

        <div>
          <label for="protein2_conc" class="block text-sm font-medium text-gray-700 mb-1">Protein 2 Total (single point)</label>
          <div class="input-group">
            <input type="number" id="protein2_conc" value="50"
                   class="w-full px-3 py-2 bg-white border border-gray-300 rounded-md" />
            <select id="protein2_units" class="px-3 py-2 border-gray-300 rounded-md bg-white">
              <option value="nM" selected>nM</option>
              <option value="uM">µM</option>
              <option value="mM">mM</option>
            </select>
          </div>
        </div>

        <div id="kd_block">
          <label for="kd" class="block text-sm font-medium text-gray-700 mb-1">
            Dissociation Constant <span id="kd_label_span"></span>
          </label>
          <div class="input-group">
            <input type="number" id="kd" value="100"
                   class="w-full px-3 py-2 bg-white border border-gray-300 rounded-md" />
            <select id="kd_units" class="px-3 py-2 border-gray-300 rounded-md bg-white">
              <option value="nM" selected>nM</option>
              <option value="uM">µM</option>
              <option value="mM">mM</option>
            </select>
          </div>
          <p id="kd_help" class="text-xs text-gray-500 mt-1"></p>
        </div>

        <div id="coop_block" class="hidden">
            <label for="cooperativity" class="block text-sm font-medium text-gray-700 mb-1">
                Cooperativity (α)
            </label>
            <input type="number" id="cooperativity" value="1.0" step="0.1"
                 class="w-full px-3 py-2 bg-white border border-gray-300 rounded-md">
            <p class="text-xs text-gray-500 mt-1">α=1: Independent. α&lt;1: Positive cooperativity. α&gt;1: Negative.</p>
        </div>

        <div id="validationMsg" class="text-red-600 text-sm"></div>
      </div>

      <div class="bg-white p-6 rounded-xl shadow-lg">
        <h2 class="text-2xl font-semibold text-gray-800 border-b pb-3">Equilibrium (single point)</h2>
        <div id="results" class="space-y-4 mt-4">
          <p class="text-gray-500">Results will appear here.</p>
        </div>
      </div>

      <!-- QOF additions: MW + Temperature + ΔG -->
      <div class="bg-white p-6 rounded-xl shadow-lg space-y-4">
        <h3 class="text-xl font-semibold">Physical Properties & ΔG</h3>
        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-1">P1 Molecular Weight (kDa)</label>
            <input type="number" id="mw_p1" value="150" class="w-full px-3 py-2 border border-gray-300 rounded-md">
          </div>
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-1">P2 Molecular Weight (kDa)</label>
            <input type="number" id="mw_p2" value="25" class="w-full px-3 py-2 border border-gray-300 rounded-md">
          </div>
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-1">Temperature (°C)</label>
            <input type="number" id="temp_c" value="25" class="w-full px-3 py-2 border border-gray-300 rounded-md">
          </div>
        </div>
        <button id="deltaGBtn" class="btn-secondary">Compute ΔG from Kd</button>
        <div id="deltaGOut" class="text-sm mono mt-2"></div>
      </div>

      <!-- QOF additions: Target occupancy solver -->
      <div class="bg-white p-6 rounded-xl shadow-lg space-y-4">
        <h3 class="text-xl font-semibold">Target Occupancy Solver</h3>
        <p class="text-sm text-gray-600">Solve for the required total [P2] to reach a desired occupancy at the current [P1] and Kd.</p>
        <div class="grid grid-cols-1 sm:grid-cols-3 gap-4">
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-1">Target %</label>
            <input type="number" id="target_pct" value="90" class="w-full px-3 py-2 border border-gray-300 rounded-md">
          </div>
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-1">Definition</label>
            <select id="target_mode" class="w-full px-3 py-2 bg-white border border-gray-300 rounded-md">
              <option value="single_complex">Single-step: % of P1 in P1·(P2)<sub>n</sub></option>
              <option value="any_bound">Stepwise: % P1 with ≥1 P2</option>
              <option value="fully_bound">Stepwise: % P1 with n P2</option>
            </select>
          </div>
          <div class="flex items-end">
            <button id="solveTargetBtn" class="btn w-full">Solve required [P2]<sub>total</sub></button>
          </div>
        </div>
        <div id="targetOut" class="text-sm mono mt-2"></div>
      </div>

      <!-- QOF additions: Mixing helper -->
      <div class="bg-white p-6 rounded-xl shadow-lg space-y-4">
        <h3 class="text-xl font-semibold">Mixing Helper</h3>
        <p class="text-sm text-gray-600">Compute volumes to mix from stock solutions to hit the totals above at a chosen final volume.</p>
        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-1">P1 Stock</label>
            <div class="input-group">
              <input type="number" id="p1_stock" value="100" class="w-full px-3 py-2 border border-gray-300 rounded-md">
              <select id="p1_stock_u" class="px-3 py-2 border-gray-300 rounded-md bg-white">
                <option value="uM">µM</option>
                <option value="nM">nM</option>
                <option value="mM">mM</option>
              </select>
            </div>
          </div>
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-1">P2 Stock</label>
            <div class="input-group">
              <input type="number" id="p2_stock" value="100" class="w-full px-3 py-2 border border-gray-300 rounded-md">
              <select id="p2_stock_u" class="px-3 py-2 border-gray-300 rounded-md bg-white">
                <option value="uM">µM</option>
                <option value="nM">nM</option>
                <option value="mM">mM</option>
              </select>
            </div>
          </div>
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-1">Final Volume (µL)</label>
            <input type="number" id="final_vol" value="50" class="w-full px-3 py-2 border border-gray-300 rounded-md">
          </div>
          <div class="flex items-end">
            <button id="mixBtn" class="btn-secondary w-full">Compute mix volumes</button>
          </div>
        </div>
        <div id="mixOut" class="text-sm mono mt-2"></div>
      </div>

    </div>

    <div class="lg:col-span-3 space-y-8">
      <div class="bg-white p-6 rounded-xl shadow-lg">
        <h2 class="text-2xl font-semibold text-gray-800">Saturation Binding Curve</h2>
        <p class="text-sm text-gray-500 mb-4">
          Titrate P2 against fixed P1. Choose what to plot for the stepwise model.
        </p>

        <div class="mb-4 grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <label class="block text-sm font-medium text-gray-700">P2 Titration Start</label>
            <input type="number" id="p2_start" value="0.1" class="mt-1 w-full px-3 py-2 border border-gray-300 rounded-md">
          </div>
          <div>
            <label class="block text-sm font-medium text-gray-700">P2 Titration End</label>
            <input type="number" id="p2_end" value="1000" class="mt-1 w-full px-3 py-2 border border-gray-300 rounded-md">
          </div>
          <div>
            <label class="block text-sm font-medium text-gray-700">Number of Points</label>
            <input type="number" id="plot_points" value="100" class="mt-1 w-full px-3 py-2 border border-gray-300 rounded-md">
          </div>
          <div class="flex items-end">
            <label class="flex items-center space-x-2 cursor-pointer">
              <input type="checkbox" id="log_scale" class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
              <span class="text-sm font-medium text-gray-700">Logarithmic X‑axis</span>
            </label>
          </div>
        </div>

        <div class="mb-4 grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
                <label class="block text-sm font-medium text-gray-700">Signal Definition</label>
                <select id="signal_mode" class="mt-1 w-full px-3 py-2 border border-gray-300 rounded-md">
                    <option value="linear" selected>Linear (sum of bound sites)</option>
                    <option value="threshold">Threshold (fully bound only)</option>
                </select>
            </div>
            <div>
                <label class="block text-sm font-medium text-gray-700">Y-Axis Display</label>
                <select id="y_axis_mode" class="mt-1 w-full px-3 py-2 border border-gray-300 rounded-md">
                    <option value="concentration" selected>Molar Concentration</option>
                    <option value="normalized">Normalized Signal (%)</option>
                </select>
            </div>
        </div>

        <div class="flex items-center gap-2 mb-3">
          <button id="freezeRefBtn" class="bg-yellow-600 hover:bg-yellow-700 text-white font-semibold py-2 px-4 rounded-lg">Freeze Reference</button>
          <button id="exportPlotCsv" class="btn-secondary">Export curve data (CSV)</button>
          <button id="savePngBtn" class="btn-secondary">Save chart (PNG)</button>
        </div>
        <canvas id="complexFormationChart"></canvas>
        <div class="mt-8">
            <h3 class="text-lg font-semibold text-gray-800 mb-2">Species Landscape</h3>
            <canvas id="speciesChart"></canvas>
        </div>
      </div>

      <div class="bg-white p-6 rounded-xl shadow-lg">
        <h3 class="text-xl font-semibold">Species Breakdown (stepwise model)</h3>
        <p class="text-sm text-gray-500">Populations at the single‑point conditions above. Useful for SEC or cryo‑EM occupancy planning.</p>
        <div class="flex items-center gap-2 mb-2">
          <button id="exportSpeciesCsv" class="btn-secondary">Export species (CSV)</button>
        </div>
        <div class="overflow-x-auto">
          <table class="min-w-full text-sm">
            <thead>
              <tr class="text-left border-b">
                <th class="py-2 pr-4">k</th>
                <th class="py-2 pr-4">Fraction of P1</th>
                <th class="py-2 pr-4">[P1·(P2)<sub>k</sub>] (P1 units)</th>
                <th class="py-2 pr-4">Mass conc. (mg/mL)</th>
              </tr>
            </thead>
            <tbody id="speciesBody">
              <tr><td class="py-1" colspan="4" class="text-gray-500">Run Calculate to populate.</td></tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(function initKdCalculator() {
  const els = {
    model: document.getElementById('model'),
    n: document.getElementById('stoichiometry'),
    p1: document.getElementById('protein1_conc'),
    p1u: document.getElementById('protein1_units'),
    p2: document.getElementById('protein2_conc'),
    p2u: document.getElementById('protein2_units'),
    kd: document.getElementById('kd'),
    kdu: document.getElementById('kd_units'),
    kdLabelSpan: document.getElementById('kd_label_span'),
    kdHelp: document.getElementById('kd_help'),
    validate: document.getElementById('validationMsg'),
    results: document.getElementById('results'),
    calc: document.getElementById('calculateBtn'),
    chartCanvas: document.getElementById('complexFormationChart'),
    p2Start: document.getElementById('p2_start'),
    p2End: document.getElementById('p2_end'),
    nPts: document.getElementById('plot_points'),
    log: document.getElementById('log_scale'),
    // QOF elements
    mwP1: document.getElementById('mw_p1'),
    mwP2: document.getElementById('mw_p2'),
    tempC: document.getElementById('temp_c'),
    deltaGBtn: document.getElementById('deltaGBtn'),
    deltaGOut: document.getElementById('deltaGOut'),
    targetPct: document.getElementById('target_pct'),
    targetMode: document.getElementById('target_mode'),
    solveTargetBtn: document.getElementById('solveTargetBtn'),
    targetOut: document.getElementById('targetOut'),
    p1Stock: document.getElementById('p1_stock'),
    p1StockU: document.getElementById('p1_stock_u'),
    p2Stock: document.getElementById('p2_stock'),
    p2StockU: document.getElementById('p2_stock_u'),
    finalVol: document.getElementById('final_vol'),
    mixBtn: document.getElementById('mixBtn'),
    mixOut: document.getElementById('mixOut'),
    speciesBody: document.getElementById('speciesBody'),
    exportSpeciesCsv: document.getElementById('exportSpeciesCsv'),
    exportPlotCsv: document.getElementById('exportPlotCsv'),
    savePngBtn: document.getElementById('savePngBtn'),
    coop: document.getElementById('cooperativity'),
    coopBlock: document.getElementById('coop_block'),
    signalMode: document.getElementById('signal_mode'),
    yAxisMode: document.getElementById('y_axis_mode'),
    freezeRefBtn: document.getElementById('freezeRefBtn'),
    speciesChartCanvas: document.getElementById('speciesChart'),
  };

  const FACTORS = { nM: 1, uM: 1000, mM: 1000000 };

  function to_nM(v, unit) { return v * (FACTORS[unit] || 1); }
  function from_nM(v_nM, unit) { return v_nM / (FACTORS[unit] || 1); }

  function clamp0(x) { return (x < 0 && Math.abs(x) < 1e-12) ? 0 : x; }

  function updateKdLabel() {
    const model = els.model.value;
    const n = parseInt(els.n.value);
    if (model === 'single_step') {
      els.kdLabelSpan.innerHTML = `K<sub>d</sub>`;
      const unit = els.kdu.value;
      els.kdHelp.textContent = `For the single‑step n‑mer model, the units are ${unit}^${n}. The code converts to nM^${n} internally.`;
      els.coopBlock.classList.add('hidden');
    } else {
      els.kdLabelSpan.innerHTML = `Intrinsic K<sub>d</sub> (per‑site)`;
      const unit = els.kdu.value;
      els.kdHelp.textContent = `Intrinsic Kd for the first binding event. Adjusted by cooperativity α for subsequent steps.`;
      els.coopBlock.classList.remove('hidden');
    }
  }

  function kd_to_internal_single_step(kd_val, kd_unit, n) {
    return kd_val * Math.pow(FACTORS[kd_unit] || 1, n);
  }

  function f_single_step(x, P1_tot, P2_tot, Kd_int, n) {
    const P1_free = P1_tot - x;
    const P2_free = P2_tot - n * x;
    if (P1_free < 0 || P2_free < 0) return Number.POSITIVE_INFINITY;
    return P1_free * Math.pow(P2_free, n) - Kd_int * x;
  }

  function solve_single_step(P1_tot, P2_tot, Kd_int, n) {
    let low = 0;
    let high = Math.min(P1_tot, P2_tot / n);
    if (P1_tot <= 0 || P2_tot <= 0) return 0;
    // Bisection bracket
    for (let i = 0; i < 200; i++) {
      const mid = 0.5 * (low + high);
      const fmid = f_single_step(mid, P1_tot, P2_tot, Kd_int, n);
      if (Math.abs(fmid) < 1e-12) return mid;
      const flow = f_single_step(low, P1_tot, P2_tot, Kd_int, n);
      if (Math.sign(flow) === Math.sign(fmid)) { low = mid; } else { high = mid; }
    }
    return 0.5 * (low + high);
  }

  function solve_11_analytic(P1_tot, P2_tot, Kd) {
    const S = P1_tot + P2_tot + Kd;
    const disc = S*S - 4*P1_tot*P2_tot;
    return (S - Math.sqrt(Math.max(disc, 0))) / 2;
  }

  // Generalized stepwise solver with cooperativity (alpha)
  function solve_stepwise_general(P_tot, L_tot, Kd_intrinsic, n, alpha) {
      if (P_tot <= 0) return { L: Math.max(L_tot, 0), theta: 0, probs: Array(n+1).fill(0), concs: Array(n+1).fill(0) };

      // Beta factors: beta_k = binom(n, k) * (1/Kd_intrinsic)^k * (1/alpha)^(k*(k-1)/2)
      // Note: This assumes Kd_intrinsic is the microscopic Kd for the FIRST binding event.
      // And Kd for k-th event (microscopic) is Kd_intrinsic * alpha^(k-1).
      // So K_assoc_micro_k = 1 / (Kd_intrinsic * alpha^(k-1))
      // beta_k = product of macro K_assoc from 1 to k.
      // Macro K_assoc_k = K_assoc_micro_k * (n - k + 1) / k

      const betas = [1];
      for (let k = 1; k <= n; k++) {
          const micro_Kd_k = Kd_intrinsic * Math.pow(alpha, k - 1);
          if (micro_Kd_k <= 0) { // Infinite affinity?
               betas.push(Number.POSITIVE_INFINITY);
          } else {
               const macro_Ka_k = (1 / micro_Kd_k) * (n - k + 1) / k;
               betas.push(betas[k - 1] * macro_Ka_k);
          }
      }

      // Binding polynomial Z(L) = sum(beta_k * L^k)
      // Conservation: L_total = L + P_total * ( sum(k * beta_k * L^k) / Z(L) )

      const f = (L) => {
          let Z = 0;
          let sum_k_beta_Lk = 0;
          for (let k = 0; k <= n; k++) {
              const term = betas[k] * Math.pow(L, k);
              Z += term;
              sum_k_beta_Lk += k * term;
          }
          const v_bar = Z > 0 ? (sum_k_beta_Lk / Z) : 0;
          return L + P_tot * v_bar - L_tot;
      };

      // Bisection
      let low = 0;
      let high = Math.max(L_tot, Kd_intrinsic * 1e3); // Heuristic max
      if (f(high) < 0) {
           // Exponential search for upper bound
           while(f(high) < 0) { high *= 2; if (high > 1e18) break; }
      }

      for (let i = 0; i < 100; i++) {
          const mid = 0.5 * (low + high);
          const val = f(mid);
          if (Math.abs(val) < 1e-12 * (L_tot + 1e-9)) { low = high = mid; break; }
          if (val > 0) high = mid; else low = mid;
      }
      const L = 0.5 * (low + high);

      // Compute species
      const species_rel = [];
      let Z = 0;
      for(let k=0; k<=n; k++){
          const term = betas[k] * Math.pow(L, k);
          species_rel.push(term);
          Z += term;
      }
      const probs = species_rel.map(v => v/Z);
      const concs = probs.map(p => p * P_tot);
      let avg_bound = 0;
      for(let k=0; k<=n; k++) avg_bound += k * probs[k];
      const theta = avg_bound / n;

      return { L, theta, probs, concs };
  }

  function species_stepwise(P_tot, L_tot, Kd_site, n) {
      // Wrapper for existing calls, assuming alpha=1
      const alpha = parseFloat(els.coop.value) || 1.0;
      return solve_stepwise_general(P_tot, L_tot, Kd_site, n, alpha);
  }

  function binom(n, k) {
    if (k < 0 || k > n) return 0;
    if (k === 0 || k === n) return 1;
    k = Math.min(k, n - k);
    let res = 1;
    for (let i = 1; i <= k; i++) res = (res * (n - k + i)) / i;
    return res;
  }

  let chartInstance = null;
  let speciesChartInstance = null;
  let lastCurveData = null; // for CSV export
  let referenceCurve = null;

  function updatePlot() {
    const model = els.model.value;
    const n = parseInt(els.n.value);
    const P1_tot = to_nM(parseFloat(els.p1.value), els.p1u.value);
    const kd_val = parseFloat(els.kd.value);
    const kd_unit = els.kdu.value;

    const start_val = parseFloat(els.p2Start.value);
    const end_val = parseFloat(els.p2End.value);
    const num_points = parseInt(els.nPts.value);
    const use_log = els.log.checked;

    const p2_units = els.p2u.value;
    const p1_units = els.p1u.value;

    // Viz options
    const sigMode = els.signalMode.value; // linear vs threshold
    const yMode = els.yAxisMode.value; // concentration vs normalized

    if (!(num_points > 1) || !(end_val > 0) || !(start_val >= 0) || (use_log && start_val <= 0)) return;

    const labels = [];
    const complexData = []; // Main curve
    const speciesDatas = []; // for k=0..n, used in Species Landscape
    for (let k = 0; k <= n; k++) speciesDatas.push([]);

    lastCurveData = { x: [], columns: [] };

    // Solvers loop
    for (let i = 0; i < num_points; i++) {
        const p2_val = use_log
          ? start_val * Math.pow(end_val / start_val, i / (num_points - 1))
          : start_val + (end_val - start_val) * (i / (num_points - 1));
        const total_L = to_nM(p2_val, p2_units);
        labels.push(p2_val);

        let signal_val = 0;
        let species_concs = []; // array of [P1_k] in nM

        if (model === 'single_step') {
            const Kd_int = kd_to_internal_single_step(kd_val, kd_unit, n);
            const x = solve_single_step(P1_tot, total_L, Kd_int, n); // [P1(P2)n]
            // Species for single step: k=0 is P1_free, k=n is x. Others 0.
            const p1_free = P1_tot - x;
            for(let k=0; k<=n; k++) {
                if (k===0) species_concs[k] = p1_free;
                else if (k===n) species_concs[k] = x;
                else species_concs[k] = 0;
            }

            // Signal logic
            if (sigMode === 'threshold') {
                signal_val = x; // Only full complex
            } else {
                // Linear (sum of bound sites): n * [Complex]
                signal_val = n * x;
            }
        } else {
            // Stepwise
            const Kd_site = to_nM(kd_val, kd_unit);
            const res = species_stepwise(P1_tot, total_L, Kd_site, n);
            species_concs = res.concs; // [P1_0, P1_1, ... P1_n]

            if (sigMode === 'threshold') {
                // Only fully bound state P1_n
                signal_val = species_concs[n];
            } else {
                // Linear: sum of k * [P1_k]. (Total bound P2)
                // "Molar Concentration" of what? If linear signal, usually total bound ligand?
                // Or maybe "Average sites" scaled?
                // The user prompt: "Complex generates signal linearly (1:1)"
                // Let's assume it means Total Bound P2 = sum(k * [P1_k]).
                let bound_p2 = 0;
                for(let k=0; k<=n; k++) bound_p2 += k * species_concs[k];
                signal_val = bound_p2;

                // Wait, if Y-Axis is "Molar Concentration", showing "Total Bound P2" is valid (nM).
                // If Y-Axis is "Normalized", we normalize by max possible signal.
            }
        }

        // Apply Y-Axis Mode
        let plotted_y = 0;
        if (yMode === 'normalized') {
             // Normalize. Max possible signal?
             // For Threshold: Max is P1_total (if all P1 -> P1_n)
             // For Linear (Total bound P2): Max is n * P1_total.
             let max_sig = (sigMode === 'threshold') ? P1_tot : (n * P1_tot);
             // Avoid div/0
             plotted_y = max_sig > 0 ? (100 * signal_val / max_sig) : 0;
        } else {
             // Concentration
             plotted_y = from_nM(signal_val, p1_units);
        }

        complexData.push(plotted_y);

        // Store species data (always concentration)
        for(let k=0; k<=n; k++) {
             speciesDatas[k].push(from_nM(species_concs[k], p1_units));
        }
    } // end loop

    // Build Main Datasets
    const datasets = [];

    // Reference Trace
    if (referenceCurve) {
        datasets.push({
            label: 'Reference (Frozen)',
            data: referenceCurve,
            borderWidth: 2,
            borderDash: [5, 5],
            borderColor: 'rgb(156, 163, 175)', // gray-400
            backgroundColor: 'transparent',
            pointRadius: 0,
            tension: 0.1
        });
    }

    // Active Trace
    let yLabel = (yMode === 'normalized') ? 'Signal (%)' : `Concentration [${p1_units}]`;
    let mainLabel = (sigMode === 'threshold') ? 'Fully Bound Complex' : 'Total Binding Signal';

    datasets.push({
        label: mainLabel,
        data: complexData,
        borderWidth: 3,
        borderColor: 'rgb(79, 70, 229)',
        backgroundColor: 'rgba(79, 70, 229, 0.1)',
        pointRadius: 0,
        tension: 0.1
    });

    if (chartInstance) chartInstance.destroy();
    chartInstance = new Chart(els.chartCanvas.getContext('2d'), {
      type: 'line', data: { labels, datasets },
      options: {
        responsive: true, maintainAspectRatio: true,
        scales: {
          x: { type: els.log.checked ? 'logarithmic' : 'linear', title: { display: true, text: `[P2] (${p2_units})`, font: { size: 14 } } },
          y: { beginAtZero: true, title: { display: true, text: yLabel, font: { size: 14 } } },
        },
        plugins: { tooltip: { mode: 'index', intersect: false } }
      }
    });

    // Update Species Landscape (Stacked Area)
    const speciesDatasets = [];
    const colors = ['#9ca3af', '#f87171', '#fbbf24', '#34d399', '#60a5fa', '#818cf8', '#a78bfa', '#f472b6']; // arbitrary palette
    for (let k = 0; k <= n; k++) {
        const color = colors[k % colors.length];
        speciesDatasets.push({
            label: `P1·(P2)${k}`,
            data: speciesDatas[k],
            fill: true,
            backgroundColor: color + '80', // 50% opacity
            borderColor: color,
            borderWidth: 1,
            pointRadius: 0
        });
    }

    if (speciesChartInstance) speciesChartInstance.destroy();
    speciesChartInstance = new Chart(els.speciesChartCanvas.getContext('2d'), {
        type: 'line',
        data: { labels, datasets: speciesDatasets },
        options: {
            responsive: true, maintainAspectRatio: true,
            scales: {
                x: { type: els.log.checked ? 'logarithmic' : 'linear', title: { display: true, text: `[P2] (${p2_units})` } },
                y: { stacked: true, beginAtZero: true, title: { display: true, text: `Species Conc. [${p1_units}]` } }
            },
            plugins: {
                tooltip: { mode: 'index', intersect: false },
                legend: { position: 'right' }
            },
            elements: { point: { radius: 0 } }
        }
    });

    // Save for export
    lastCurveData = { x: labels, columns: [{ name: mainLabel, data: complexData }] };
  }

  function freezeReference() {
      if (referenceCurve) {
          // Unfreeze / Clear
          referenceCurve = null;
          els.freezeRefBtn.textContent = "Freeze Reference";
          els.freezeRefBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
          els.freezeRefBtn.classList.add('bg-yellow-600', 'hover:bg-yellow-700');
          // Re-enable inputs
          [els.p2Start, els.p2End, els.nPts, els.log].forEach(el => el.disabled = false);
      } else {
          // Freeze
          if (chartInstance && chartInstance.data.datasets.length > 0) {
              const activeDs = chartInstance.data.datasets[chartInstance.data.datasets.length - 1];
              referenceCurve = [...activeDs.data];
              els.freezeRefBtn.textContent = "Clear Reference";
              els.freezeRefBtn.classList.remove('bg-yellow-600', 'hover:bg-yellow-700');
              els.freezeRefBtn.classList.add('bg-red-600', 'hover:bg-red-700');
              // Disable inputs to maintain X-axis consistency
              [els.p2Start, els.p2End, els.nPts, els.log].forEach(el => el.disabled = true);
          }
      }
      updatePlot();
  }

  function validateInputs() {
    const errs = [];
    const n = parseInt(els.n.value), p1 = parseFloat(els.p1.value), p2 = parseFloat(els.p2.value), kd = parseFloat(els.kd.value);
    if (!(Number.isInteger(n) && n >= 1)) errs.push('Stoichiometry n must be an integer ≥ 1.');
    if (!(p1 >= 0)) errs.push('Protein 1 total must be ≥ 0.');
    if (!(p2 >= 0)) errs.push('Protein 2 total must be ≥ 0.');
    if (!(kd > 0)) errs.push('Kd must be > 0.');
    els.validate.textContent = errs.join(' ');
    return errs.length === 0;
  }

  function runSinglePoint() {
    if (!validateInputs()) { els.results.innerHTML = `<div class="text-red-600 bg-red-100 p-3 rounded-lg">Please correct the inputs.</div>`; return; }
    const model = els.model.value;
    const n = parseInt(els.n.value);
    const P1_tot = to_nM(parseFloat(els.p1.value), els.p1u.value);
    const P2_tot = to_nM(parseFloat(els.p2.value), els.p2u.value);
    const kd_val = parseFloat(els.kd.value);
    const kd_unit = els.kdu.value;
    let html = '';

    if (model === 'single_step') {
      const Kd_int = kd_to_internal_single_step(kd_val, kd_unit, n);
      const x = solve_single_step(P1_tot, P2_tot, Kd_int, n);
      const P1_free = clamp0(P1_tot - x);
      const P2_free = clamp0(P2_tot - n * x);
      const pctP1 = (P1_tot > 0) ? (100 * x / P1_tot) : 0;
      html += `<div class="grid grid-cols-1 md:grid-cols-2 gap-3">
          <div class="p-3 bg-indigo-50 rounded-lg"><h4 class="font-semibold text-indigo-800">[P1·(P2)<sub>${n}</sub>]</h4><p class="text-xl text-indigo-900">${from_nM(x, els.p1u.value).toPrecision(6)} ${els.p1u.value}</p></div>
          <div class="p-3 bg-green-50 rounded-lg"><h4 class="font-semibold text-green-800">[P1]<sub>free</sub></h4><p class="text-xl text-green-900">${from_nM(P1_free, els.p1u.value).toPrecision(6)} ${els.p1u.value}</p></div>
          <div class="p-3 bg-blue-50 rounded-lg"><h4 class="font-semibold text-blue-800">[P2]<sub>free</sub></h4><p class="text-xl text-blue-900">${from_nM(P2_free, els.p2u.value).toPrecision(6)} ${els.p2u.value}</p></div>
          <div class="p-3 bg-gray-100 rounded-lg"><h4 class="font-semibold text-gray-800">% of P1 in complex</h4><p class="text-xl text-gray-900">${pctP1.toFixed(2)}%</p></div>
        </div>`;
      els.results.innerHTML = html;
      // Clear species table for single-step (not defined per k)
      renderSpeciesTable(null);
    } else {
      const Kd_site = to_nM(kd_val, kd_unit);
      const { L, theta, probs, concs } = species_stepwise(P1_tot, P2_tot, Kd_site, n);
      const prob0 = Math.pow(1 - theta, n);
      const probN = Math.pow(theta, n);
      const P1_any = P1_tot * (1 - prob0);
      const P1_full = P1_tot * probN;
      const bound_sites = n * theta;
      const P1_free = P1_tot - P1_any;
      html += `<div class="grid grid-cols-1 md:grid-cols-2 gap-3">
          <div class="p-3 bg-green-50 rounded-lg"><h4 class="font-semibold text-green-800">[P1]<sub>free</sub> (0 bound)</h4><p class="text-xl text-green-900">${from_nM(P1_free, els.p1u.value).toPrecision(6)} ${els.p1u.value}</p></div>
          <div class="p-3 bg-blue-50 rounded-lg"><h4 class="font-semibold text-blue-800">[P2]<sub>free</sub></h4><p class="text-xl text-blue-900">${from_nM(L, els.p2u.value).toPrecision(6)} ${els.p2u.value}</p></div>
          <div class="p-3 bg-indigo-50 rounded-lg"><h4 class="font-semibold text-indigo-800">[P1 with ≥1 P2]</h4><p class="text-xl text-indigo-900">${from_nM(P1_any, els.p1u.value).toPrecision(6)} ${els.p1u.value}</p></div>
          <div class="p-3 bg-purple-50 rounded-lg"><h4 class="font-semibold text-purple-800">[P1 with n P2]</h4><p class="text-xl text-purple-900">${from_nM(P1_full, els.p1u.value).toPrecision(6)} ${els.p1u.value}</p></div>
          <div class="p-3 bg-amber-50 rounded-lg"><h4 class="font-semibold text-amber-800">Average bound sites per P1</h4><p class="text-xl text-amber-900">${bound_sites.toPrecision(6)} of ${n}</p></div>
        </div>`;
      els.results.innerHTML = html;
      renderSpeciesTable({ probs, concs });
    }
  }

  function renderSpeciesTable(data) {
    const mwP1 = parseFloat(els.mwP1.value) || 0;
    const mwP2 = parseFloat(els.mwP2.value) || 0;
    const p1_units = els.p1u.value;
    if (!data) {
      els.speciesBody.innerHTML = `<tr><td class="py-1" colspan="4" class="text-gray-500">Single‑step model does not define intermediate species.</td></tr>`;
      return;
    }
    const { probs, concs } = data;
    let rows = '';
    for (let k = 0; k < probs.length; k++) {
      const frac = probs[k];
      const conc_unit = from_nM(concs[k], p1_units);
      // mg/mL = (Molar conc in mol/L) * (MW in g/mol) -> g/L -> mg/mL
      // We only have [P1·(P2)_k] in P1 units. Convert that to mol/L:
      // Convert concs[k] nM to mol/L: concs[k] * 1e-9
      const mw_complex_kDa = mwP1 + k * mwP2;
      const mg_per_ml = (concs[k] * 1e-9) * (mw_complex_kDa * 1000) / 1e3; // g/L to mg/mL
      rows += `<tr class="border-b">
        <td class="py-1 pr-4"> ${k} </td>
        <td class="py-1 pr-4"> ${(frac*100).toFixed(2)}% </td>
        <td class="py-1 pr-4"> ${conc_unit.toPrecision(6)} ${p1_units} </td>
        <td class="py-1 pr-4"> ${isFinite(mg_per_ml) ? mg_per_ml.toExponential(3) : '—'} </td>
      </tr>`;
    }
    els.speciesBody.innerHTML = rows;
  }

  function runAll() {
    if (!validateInputs()) return;
    runSinglePoint();
    updatePlot();
  }

  function selfTests() {
    const lines = [];
    {
      const P1 = 10, P2 = 50, Kd = 100;
      const xA = solve_11_analytic(P1, P2, Kd);
      const xN = solve_single_step(P1, P2, Kd, 1);
      lines.push(`Test 1 (1:1) analytic=${xA.toFixed(8)} nM, numeric=${xN.toFixed(8)} nM, diff=${Math.abs(xA-xN).toExponential(2)} nM`);
    }
    {
      const n = 2, P1 = 20, P2 = 10, Kd = 1;
      const x = solve_single_step(P1, P2, Kd, n);
      lines.push(`Test 2 (1:2 single-step, tight & P2-limited): x=${x.toFixed(8)} nM, expected≈P2/n=${(P2/n).toFixed(8)} nM`);
    }
    {
      const n = 4, P_tot = 10, L_tot = 1e6, Kd_site = 100;
      const { L, theta } = solve_stepwise_identical(P_tot, L_tot, Kd_site, n);
      lines.push(`Test 3 (stepwise, ligand excess): theta≈1 ⇒ ${theta.toFixed(6)}`);
    }
    {
      const n = 3, P_tot = 10, L_tot = 0, Kd_site = 100;
      const { L, theta } = solve_stepwise_identical(P_tot, L_tot, Kd_site, n);
      lines.push(`Test 4 (stepwise, no ligand): L=${L.toFixed(6)} nM, theta=${theta.toFixed(6)} (expect 0)`);
    }
    els.selfTestOut.textContent = lines.join('\\n');
  }

  // ΔG = RT ln(Kd)
  function computeDeltaG() {
    const model = els.model.value;
    const kd_val = parseFloat(els.kd.value);
    const kd_unit = els.kdu.value;
    if (!(kd_val > 0)) { els.deltaGOut.textContent = 'Set Kd > 0'; return; }
    const T = (parseFloat(els.tempC.value) || 25) + 273.15;
    const R = 8.314462618; // J/mol/K
    if (model === 'single_step') {
      const n = parseInt(els.n.value);
      const Kd_int_nMpow = kd_to_internal_single_step(kd_val, kd_unit, n);
      const Kd_int_Mpow = Kd_int_nMpow * Math.pow(1e-9, n); // convert to (M)^n
      // Report ΔG/n per site equivalent for comparison
      const dG_total = R * T * Math.log(Kd_int_Mpow);
      const dG_per = dG_total / n;
      els.deltaGOut.textContent = `Single‑step overall ΔG = ${(dG_total/1000).toFixed(2)} kJ/mol; per‑equivalent site ≈ ${(dG_per/1000).toFixed(2)} kJ/mol`;
    } else {
      const Kd_site_nM = to_nM(kd_val, kd_unit); // internal nM
      const Kd_site_M = Kd_site_nM * 1e-9;
      const dG_site = R * T * Math.log(Kd_site_M);
      els.deltaGOut.textContent = `Per‑site ΔG = ${(dG_site/1000).toFixed(2)} kJ/mol`;
    }
  }

  // Target occupancy solver
  function solveTarget() {
    const target_pct = parseFloat(els.targetPct.value) / 100;
    if (!(target_pct > 0 && target_pct < 1)) { els.targetOut.textContent = 'Target % must be between 0 and 100.'; return; }
    const model = els.model.value;
    const n = parseInt(els.n.value);
    const P1_tot = to_nM(parseFloat(els.p1.value), els.p1u.value);
    const kd_val = parseFloat(els.kd.value);
    const kd_unit = els.kdu.value;
    const p2_units = els.p2u.value;

    let required_P2_tot_nM = NaN;
    if (model === 'single_step' && els.targetMode.value === 'single_complex') {
      const Kd_int = kd_to_internal_single_step(kd_val, kd_unit, n);
      const x = target_pct * P1_tot;
      if (x >= P1_tot) { els.targetOut.textContent = 'Target too high.'; return; }
      const P2_free = Math.pow(Kd_int * x / (P1_tot - x), 1 / n);
      required_P2_tot_nM = n * x + P2_free;
      els.targetOut.textContent = `Required [P2]_total ≈ ${from_nM(required_P2_tot_nM, p2_units).toPrecision(6)} ${p2_units}`;
      return;
    }

    if (model === 'stepwise_identical') {
      const Kd_site = to_nM(kd_val, kd_unit);
      let theta = NaN;
      if (els.targetMode.value === 'any_bound') {
        // 1 - (1 - θ)^n = f  =>  θ = 1 - (1 - f)^(1/n)
        theta = 1 - Math.pow(1 - target_pct, 1 / n);
      } else if (els.targetMode.value === 'fully_bound') {
        // θ^n = f  =>  θ = f^(1/n)
        theta = Math.pow(target_pct, 1 / n);
      } else {
        els.targetOut.textContent = 'Switch to single-step target for that mode.';
        return;
      }
      const L = (theta / (1 - theta)) * Kd_site;  // free ligand
      const required = L + n * P1_tot * theta;    // total ligand
      required_P2_tot_nM = required;
      els.targetOut.textContent = `Required [P2]_total ≈ ${from_nM(required_P2_tot_nM, p2_units).toPrecision(6)} ${p2_units} (θ=${theta.toFixed(4)}, L_free=${from_nM(L, p2_units).toPrecision(4)} ${p2_units})`;
      return;
    }

    els.targetOut.textContent = 'This target mode is not compatible with the selected model.';
  }

  // Mixing helper
  function computeMix() {
    const P1_tot = to_nM(parseFloat(els.p1.value), els.p1u.value);
    const P2_tot = to_nM(parseFloat(els.p2.value), els.p2u.value);
    const V_final_uL = parseFloat(els.finalVol.value);
    const P1_stock = to_nM(parseFloat(els.p1Stock.value), els.p1StockU.value);
    const P2_stock = to_nM(parseFloat(els.p2Stock.value), els.p2StockU.value);
    if (!(V_final_uL > 0 && P1_stock > 0 && P2_stock > 0)) { els.mixOut.textContent = 'Set positive final volume and stock concentrations.'; return; }
    // Simple C1V1 = C2V2
    const V1_uL = (P1_tot / P1_stock) * V_final_uL;
    const V2_uL = (P2_tot / P2_stock) * V_final_uL;
    const V_buffer_uL = Math.max(V_final_uL - V1_uL - V2_uL, 0);
    els.mixOut.textContent = `Mix: V1=${V1_uL.toFixed(2)} µL of P1 stock, V2=${V2_uL.toFixed(2)} µL of P2 stock, buffer=${V_buffer_uL.toFixed(2)} µL.`;
  }

  function exportSpeciesCSV() {
    const rows = [['k', 'fraction_P1', `[P1·(P2)_k]_${els.p1u.value}`, 'mass_mg_per_mL']];
    const bodyRows = els.speciesBody.querySelectorAll('tr');
    bodyRows.forEach(tr => {
      const tds = tr.querySelectorAll('td');
      if (tds.length === 4) {
        const k = tds[0].innerText.trim();
        const frac = tds[1].innerText.trim().replace('%','');
        const conc = tds[2].innerText.trim();
        const mass = tds[3].innerText.trim();
        rows.push([k, frac, conc, mass]);
      }
    });
    downloadCSV(rows, 'species_table.csv');
  }

  function exportPlotCSV() {
    if (!lastCurveData || !lastCurveData.columns || lastCurveData.columns.length === 0) return;
    const header = ['P2 (' + els.p2u.value + ')'].concat(lastCurveData.columns.map(c => c.name));
    const rows = [header];
    for (let i = 0; i < lastCurveData.x.length; i++) {
      const row = [lastCurveData.x[i]];
      lastCurveData.columns.forEach(col => row.push(col.data[i]));
      rows.push(row);
    }
    downloadCSV(rows, 'binding_curve.csv');
  }

  function downloadCSV(rows, filename) {
    const csv = rows.map(r => r.join(',')).join('\\n');
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    link.click();
    URL.revokeObjectURL(url);
  }

  function saveChartPNG() {
    if (!chartInstance) return;
    const link = document.createElement('a');
    link.download = 'binding_chart.png';
    link.href = chartInstance.toBase64Image();
    link.click();
  }

  // Debounce utility
  function debounce(func, wait) {
      let timeout;
      return function(...args) {
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(this, args), wait);
      };
  }

  const debouncedRun = debounce(runAll, 300);

  // Attach listeners
  [els.model, els.n, els.kdu].forEach(el => el.addEventListener('change', () => { updateKdLabel(); runAll(); }));
  // Text/Number inputs trigger debounced run
  [els.p1, els.p2, els.kd, els.n, els.coop, els.p2Start, els.p2End, els.nPts].forEach(el => el.addEventListener('input', debouncedRun));
  // Selects trigger immediate run
  [els.p1u, els.p2u, els.signalMode, els.yAxisMode].forEach(el => el.addEventListener('change', runAll));

  [els.log].forEach(el => el.addEventListener('change', updatePlot));

  //els.calc.addEventListener('click', runAll); // Removed button
  els.freezeRefBtn.addEventListener('click', freezeReference);
  els.deltaGBtn.addEventListener('click', computeDeltaG);
  els.solveTargetBtn.addEventListener('click', solveTarget);
  els.mixBtn.addEventListener('click', computeMix);
  els.exportSpeciesCsv.addEventListener('click', exportSpeciesCSV);
  els.exportPlotCsv.addEventListener('click', exportPlotCSV);
  els.savePngBtn.addEventListener('click', saveChartPNG);

  updateKdLabel();
  // Run background checks
  setTimeout(selfTests, 100);
  runAll();
})();
</script>
